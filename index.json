[{"content":"原文: https://osmh.dev/posts/goroutines-under-the-hood\n简介 Go从2012年开始出现，开发人员开始认识到它的强大，并慢慢过渡到用Go开发他们的项目。它在 \u0026ldquo;现代企业 \u0026ldquo;中变得非常流行，原因有很多，其中之一是它真的很容易学习和使用，而且能产生更干净的代码！特别是如果你有C++的背景。但这并不是许多开发者支持它的唯一原因。其他原因包括它的编译和执行速度有多快，它如何通过提供自己预设的代码风格标准来提高代码的可维护性和可读性，最重要的是，它处理并发的方式\n现在让我们来关注一下go真正的特别之处，go处理并发的方式使多线程应用程序的工作速度快得惊人！但是在深入挖掘go是如何工作的之前，我们先来看看go是如何工作的。但在深入了解它是如何做到这一点的之前，让我们向后退一步，解释一下什么是并发性，什么是线程？\n如果你已经了解了并发性、并行性和线程，请随意跳到goroutines部分。\n并发与并行 维基百科对并发的定义是\u0026hellip;\u0026hellip;开玩笑，如果你从来没有听说过并发，那么维基百科对它的定义反而会把你吓跑。简而言之，并发性允许程序在同一时间处理多个事物。还需要提到的是，它并不一定意味着在CPU层面上同时处理多个任务。但尽管如此，它还是同时处理它们，现在让我们来解释一下这意味着什么，下面的内容可能对每一个使用案例都不是100%正确的，因为一些CPU或操作系统在内部有不同的操作方式。我也会暂时忽略一些技术细节，比如线程，以使其更容易理解（我将使用 \u0026ldquo;任务 \u0026ldquo;一词而不是 \u0026ldquo;线程\u0026rdquo;），并在以后进行解释。但整体过程应该不会有太大差别。\n单核CPU的并发性 CPU要么有单核，要么有多核，为了简单起见，让我们先解释一下单核CPU的并发工作原理，然后再理解多核CPU的工作原理应该是小菜一碟了。在单核CPU上，单核（处理器）可能会欺骗你，让你以为它在同时执行多个任务，而事实上发生的情况是，处理器中的任务执行是重叠的，这意味着每个任务在处理器上都有一个时间窗口来运行，然后它将被另一个任务取代，在该处理器上执行。\n换句话说，如果我们有任务 \u0026ldquo;A\u0026rdquo;，\u0026ldquo;B\u0026rdquo;，处理器可能首先分配给任务 \u0026ldquo;A \u0026ldquo;5微秒的时间来执行，然后即使任务A需要更多的时间来完成，它也会告诉任务 \u0026ldquo;B \u0026ldquo;来接管并做它需要的计算，比方说再5微秒。最后，当任务 \u0026ldquo;B \u0026ldquo;执行完毕后，任务 \u0026ldquo;A \u0026ldquo;可以再次开始处理5微秒的时间。由于它是在几乎没有时间（微秒）的情况下执行的，作为人类的你甚至不会注意到这些进程是重叠的，或者是一个接一个地执行的。它们会在屏幕上出现，好像它们是在同一时间运行的。而事实上，处理器一直在不同的时间窗口运行不同的任务，以实现并发。正如我们前面所描述的，处理器允许任务共享以处理它们需要的计算。内核层面的并发性是操作系统（operating system）调度器的责任，它是一个处理器依靠的程序来实现所有这些。\n多核CPU上的并发性和并行性 现在，多核CPU的情况如何？由于多核（多处理器）基础设施的存在，CPU现在可以在同一时间运行多个任务。这意味着它可以让多个任务在不同的处理器上同时运行。现在你可能想知道 \u0026ldquo;这是否意味着我们不再需要并发性了？\u0026ldquo;答案是否定的，这并不意味着并发性 \u0026ldquo;不再\u0026rdquo;。并发和并行是两件完全不同的事情。并发可能还会存在于多核CPU上，使其更加高效。现在你明白了并发性在单核CPU上是如何工作的。试想一下，同样的事情在每一个处理器上都会发生。这是因为每个处理器/内核都运行着我们前面谈到的操作系统调度器的一个实例。这使得处理器上的并发性得以实现。这里有一些图片，可以更好地解释这个问题，但是不要被并发性的演示所迷惑，就好像它只在一个处理器上运行，而这些进程在共享处理器。只要想象一下，它对CPU上存在的每一个处理器都做了下面图片上演示的同样的事情。\n编程语言有不同的方法来处理并发性, 如果它被语言支持的话。但这不是我们的主题，如果你有兴趣了解更多关于什么是并发的知识，我真的建议你去买Abraham Silberschatz、Peter Baer Galvin和Greg Gagne的《操作系统概念》这本书。它解释了所有这些概念以及其他有趣的东西。\n什么是线程？ 在上一节中，我们谈到了任务是如何分享处理器以运行一些计算的。事实是，任务甚至不能访问处理器，也不能直接使用它们。他们利用线程，而线程可以访问处理器。\n我所能找到的关于线程的最好的定义是Stackoverflow的pwnall。\n线程是一个执行环境，它是CPU执行指令流所需的所有信息。\n假设你正在阅读一本书，你现在想休息一下，但你希望能够回来，并从你停止的确切位置继续阅读。实现这一目标的方法之一是记下页码、行数和字数。所以你阅读一本书的执行背景就是这3个数字。\n如果你有一个室友，而她也在使用同样的技巧，她可以在你不使用这本书的时候拿走这本书，并从她停止的地方继续阅读。然后你可以把它拿回来，从你原来的地方继续读。\n线程的工作方式也是如此。一个CPU给你的错觉是它在同时进行多个计算。它通过在每个计算上花费一点时间来做到这一点。它之所以能做到这一点，是因为它为每个计算都有一个执行环境。就像你可以和你的朋友分享一本书一样，许多任务可以分享一个CPU。\n在更多的技术层面上，一个执行环境（因此是一个线程）由CPU的寄存器的值组成。\n每个线程都有自己独立的上下文，你甚至可以把一个多线程的程序看作是独立的程序，它们共同组成了一个更大的程序。这里有一张图，也许能帮助你直观地了解这一点。\n单线程进程一次只能运行一个任务，而多线程进程可以同时运行N个任务。\n线程的创建和管理有不同的方式或模式，可以这么说。一对一、多对一和多对多的模式。这基本上是用户（应用程序级别）线程和内核（操作系统级别）线程之间的映射。\nGorouting: Go处理并发问题的方式 开发人员喜欢Go的原因之一是用它来实现并发性是多么容易和有效。这是该语言固有的一部分。Goroutines利用了一个已经存在了一段时间的概念，叫做 \u0026ldquo;coroutines\u0026rdquo;，本质上意味着将一组独立执行的函数 \u0026ldquo;coroutines \u0026ldquo;复用到操作系统层面的一组实际线程上，这些线程运行在用户层面(用户空间)。这就是使coroutines具有难以置信的效率的原因。你可能想知道为什么？因为当一个程序阻塞时\u0026ndash;有些进程会因为很多原因导致线程阻塞\u0026ndash;比如调用一个阻塞的系统调用（比如从用户那里读取输入），运行时就会自动将同一操作系统线程上阻塞的程序后面排队的其他程序转移到不同的、可运行的线程，这样它们就不会被阻塞。这在一开始可能会有点让人难以消化，所以让我们用一个例子来证明。\n  首先，我们假设我们有4个goroutines需要被复用到内核级线程上，以便得到执行。我们还假设我们只需要两个内核级线程。而且我们有一个单一的处理器。   现在让我们假设Go的运行时调度器决定将goroutines像这样（出于任何原因）突击到线程上。goroutine A和B将使用左边的内核线程运行，goroutine B和C将使用右边的线程运行。我们还假设goroutines将分别运行，从放置在goroutines池底部的goroutines开始，用环绕它们的边框演示。\n  goroutines程序开始运行。但是，等等。\u0026ldquo;A \u0026ldquo;调用了一个阻塞的系统调用（例如read()语句）现在goroutine A是阻塞的，goroutine B也被阻塞了。   goroutine C 执行完毕   Go的运行时调度器现在也许会意识到，把goroutine B移到另一个可运行的线程上会是一个更好的主意，而不是永远等待goroutine A完成。   goroutine D 执行完毕   Goroutine B现在也完成了，而左边被Goroutine A占据的内核线程仍在阻塞中。   如果运行时调度器从不关心将阻塞的goroutines重新安排到另一个可运行的线程，那么goroutine B到现在也不会完成执行! 当然，这只是一个非常简单的例子，但想象一下，这发生在由成千上万个goroutine组成的更复杂、更大的程序上。差异将是巨大的! 开发者看不到这些，这就是问题的关键所在。goroutines可以非常便宜：除了堆栈的内存之外，它们几乎没有开销，而堆栈的内存只有几千字节。\n还有一件事，堆栈的大小如何？幸运的是，这也是为了更好地提高效率而进行的管理。引用go的FAQ页面上的一个答案。\n为了使堆栈变小，Go的运行时间使用可调整大小的、有边界的堆栈。一个新诞生的goroutine被赋予几千字节的空间，这几乎总是足够的。当它不够时，运行时间会自动增加（和缩小）用于存储堆栈的内存，从而使许多goroutine能够在适量的内存中生存。每个函数调用的CPU开销平均约为三条廉价指令。在同一地址空间中创建成百上千个goroutines是很实际的。如果goroutines只是线程，系统资源会在更少的数量上耗尽。\nGo通道也被用来促进goroutines之间的通信，但我不打算在本文中重点讨论这个问题。如果你有兴趣，你可以在这里阅读关于通道的工作原理\n结论 Goroutines是语言的一个固有部分。它们利用了一个叫做coroutines的概念。它们很容易使用，而且在性能上也很便宜。Go的运行时调度器将goroutines复用到线程上，当一个线程阻塞时，运行时将阻塞的goroutines转移到另一个可运行的内核线程上，以达到尽可能高的效率。Go还提供了许多支持goroutines的工具，例如用于goroutines之间通信的通道。如果你要开发一个关注并发性的应用程序或服务，你绝对应该考虑使用Go\n","permalink":"/posts/golang_goroutings_under_the_hood/","summary":"原文: https://osmh.dev/posts/goroutines-under-the-hood\n简介 Go从2012年开始出现，开发人员开始认识到它的强大，并慢慢过渡到用Go开发他们的项目。它在 \u0026ldquo;现代企业 \u0026ldquo;中变得非常流行，原因有很多，其中之一是它真的很容易学习和使用，而且能产生更干净的代码！特别是如果你有C++的背景。但这并不是许多开发者支持它的唯一原因。其他原因包括它的编译和执行速度有多快，它如何通过提供自己预设的代码风格标准来提高代码的可维护性和可读性，最重要的是，它处理并发的方式\n现在让我们来关注一下go真正的特别之处，go处理并发的方式使多线程应用程序的工作速度快得惊人！但是在深入挖掘go是如何工作的之前，我们先来看看go是如何工作的。但在深入了解它是如何做到这一点的之前，让我们向后退一步，解释一下什么是并发性，什么是线程？\n如果你已经了解了并发性、并行性和线程，请随意跳到goroutines部分。\n并发与并行 维基百科对并发的定义是\u0026hellip;\u0026hellip;开玩笑，如果你从来没有听说过并发，那么维基百科对它的定义反而会把你吓跑。简而言之，并发性允许程序在同一时间处理多个事物。还需要提到的是，它并不一定意味着在CPU层面上同时处理多个任务。但尽管如此，它还是同时处理它们，现在让我们来解释一下这意味着什么，下面的内容可能对每一个使用案例都不是100%正确的，因为一些CPU或操作系统在内部有不同的操作方式。我也会暂时忽略一些技术细节，比如线程，以使其更容易理解（我将使用 \u0026ldquo;任务 \u0026ldquo;一词而不是 \u0026ldquo;线程\u0026rdquo;），并在以后进行解释。但整体过程应该不会有太大差别。\n单核CPU的并发性 CPU要么有单核，要么有多核，为了简单起见，让我们先解释一下单核CPU的并发工作原理，然后再理解多核CPU的工作原理应该是小菜一碟了。在单核CPU上，单核（处理器）可能会欺骗你，让你以为它在同时执行多个任务，而事实上发生的情况是，处理器中的任务执行是重叠的，这意味着每个任务在处理器上都有一个时间窗口来运行，然后它将被另一个任务取代，在该处理器上执行。\n换句话说，如果我们有任务 \u0026ldquo;A\u0026rdquo;，\u0026ldquo;B\u0026rdquo;，处理器可能首先分配给任务 \u0026ldquo;A \u0026ldquo;5微秒的时间来执行，然后即使任务A需要更多的时间来完成，它也会告诉任务 \u0026ldquo;B \u0026ldquo;来接管并做它需要的计算，比方说再5微秒。最后，当任务 \u0026ldquo;B \u0026ldquo;执行完毕后，任务 \u0026ldquo;A \u0026ldquo;可以再次开始处理5微秒的时间。由于它是在几乎没有时间（微秒）的情况下执行的，作为人类的你甚至不会注意到这些进程是重叠的，或者是一个接一个地执行的。它们会在屏幕上出现，好像它们是在同一时间运行的。而事实上，处理器一直在不同的时间窗口运行不同的任务，以实现并发。正如我们前面所描述的，处理器允许任务共享以处理它们需要的计算。内核层面的并发性是操作系统（operating system）调度器的责任，它是一个处理器依靠的程序来实现所有这些。\n多核CPU上的并发性和并行性 现在，多核CPU的情况如何？由于多核（多处理器）基础设施的存在，CPU现在可以在同一时间运行多个任务。这意味着它可以让多个任务在不同的处理器上同时运行。现在你可能想知道 \u0026ldquo;这是否意味着我们不再需要并发性了？\u0026ldquo;答案是否定的，这并不意味着并发性 \u0026ldquo;不再\u0026rdquo;。并发和并行是两件完全不同的事情。并发可能还会存在于多核CPU上，使其更加高效。现在你明白了并发性在单核CPU上是如何工作的。试想一下，同样的事情在每一个处理器上都会发生。这是因为每个处理器/内核都运行着我们前面谈到的操作系统调度器的一个实例。这使得处理器上的并发性得以实现。这里有一些图片，可以更好地解释这个问题，但是不要被并发性的演示所迷惑，就好像它只在一个处理器上运行，而这些进程在共享处理器。只要想象一下，它对CPU上存在的每一个处理器都做了下面图片上演示的同样的事情。\n编程语言有不同的方法来处理并发性, 如果它被语言支持的话。但这不是我们的主题，如果你有兴趣了解更多关于什么是并发的知识，我真的建议你去买Abraham Silberschatz、Peter Baer Galvin和Greg Gagne的《操作系统概念》这本书。它解释了所有这些概念以及其他有趣的东西。\n什么是线程？ 在上一节中，我们谈到了任务是如何分享处理器以运行一些计算的。事实是，任务甚至不能访问处理器，也不能直接使用它们。他们利用线程，而线程可以访问处理器。\n我所能找到的关于线程的最好的定义是Stackoverflow的pwnall。\n线程是一个执行环境，它是CPU执行指令流所需的所有信息。\n假设你正在阅读一本书，你现在想休息一下，但你希望能够回来，并从你停止的确切位置继续阅读。实现这一目标的方法之一是记下页码、行数和字数。所以你阅读一本书的执行背景就是这3个数字。\n如果你有一个室友，而她也在使用同样的技巧，她可以在你不使用这本书的时候拿走这本书，并从她停止的地方继续阅读。然后你可以把它拿回来，从你原来的地方继续读。\n线程的工作方式也是如此。一个CPU给你的错觉是它在同时进行多个计算。它通过在每个计算上花费一点时间来做到这一点。它之所以能做到这一点，是因为它为每个计算都有一个执行环境。就像你可以和你的朋友分享一本书一样，许多任务可以分享一个CPU。\n在更多的技术层面上，一个执行环境（因此是一个线程）由CPU的寄存器的值组成。\n每个线程都有自己独立的上下文，你甚至可以把一个多线程的程序看作是独立的程序，它们共同组成了一个更大的程序。这里有一张图，也许能帮助你直观地了解这一点。\n单线程进程一次只能运行一个任务，而多线程进程可以同时运行N个任务。\n线程的创建和管理有不同的方式或模式，可以这么说。一对一、多对一和多对多的模式。这基本上是用户（应用程序级别）线程和内核（操作系统级别）线程之间的映射。\nGorouting: Go处理并发问题的方式 开发人员喜欢Go的原因之一是用它来实现并发性是多么容易和有效。这是该语言固有的一部分。Goroutines利用了一个已经存在了一段时间的概念，叫做 \u0026ldquo;coroutines\u0026rdquo;，本质上意味着将一组独立执行的函数 \u0026ldquo;coroutines \u0026ldquo;复用到操作系统层面的一组实际线程上，这些线程运行在用户层面(用户空间)。这就是使coroutines具有难以置信的效率的原因。你可能想知道为什么？因为当一个程序阻塞时\u0026ndash;有些进程会因为很多原因导致线程阻塞\u0026ndash;比如调用一个阻塞的系统调用（比如从用户那里读取输入），运行时就会自动将同一操作系统线程上阻塞的程序后面排队的其他程序转移到不同的、可运行的线程，这样它们就不会被阻塞。这在一开始可能会有点让人难以消化，所以让我们用一个例子来证明。\n  首先，我们假设我们有4个goroutines需要被复用到内核级线程上，以便得到执行。我们还假设我们只需要两个内核级线程。而且我们有一个单一的处理器。   现在让我们假设Go的运行时调度器决定将goroutines像这样（出于任何原因）突击到线程上。goroutine A和B将使用左边的内核线程运行，goroutine B和C将使用右边的线程运行。我们还假设goroutines将分别运行，从放置在goroutines池底部的goroutines开始，用环绕它们的边框演示。\n  goroutines程序开始运行。但是，等等。\u0026ldquo;A \u0026ldquo;调用了一个阻塞的系统调用（例如read()语句）现在goroutine A是阻塞的，goroutine B也被阻塞了。   goroutine C 执行完毕   Go的运行时调度器现在也许会意识到，把goroutine B移到另一个可运行的线程上会是一个更好的主意，而不是永远等待goroutine A完成。   goroutine D 执行完毕   Goroutine B现在也完成了，而左边被Goroutine A占据的内核线程仍在阻塞中。   如果运行时调度器从不关心将阻塞的goroutines重新安排到另一个可运行的线程，那么goroutine B到现在也不会完成执行!","title":"[Golang]goroutings本质"},{"content":"简单的文件服务器 package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享.\n然后写一个函数放到bash.rc 或zshrc中\n#文件服务器 function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err != nil { log.Fatal(err) } } EOF } OSX MP16 ~/Downloads ❯ fileserver start file server :12345 Python中有相同的功能\npython3 -m SimpleHTTPServer 7777 或 python3 -m http.server\n一个简单的WebServer package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;Hello World!\\n\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} \t})  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } 访问一下试试:\nOSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345 Hello World! http.HandleFunc http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t//... \t}) 该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;\u0026lt;h1 style=\\\u0026#34;color:Tomato;\\\u0026#34;\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  //... } 函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息\n比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequest\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tkeys, ok := r.URL.Query()[\u0026#34;key\u0026#34;] \tif !ok || len(keys[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;) \tw.WriteHeader(http.StatusBadRequest) \t_, err := w.Write([]byte(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;)) \tif err != nil { \tlog.Println(err) \treturn \t} \treturn \t}  \tkey := keys[0] \tswitch key { \tcase \u0026#34;date\u0026#34;: \tw.WriteHeader(http.StatusOK) \t_, err := w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) \tif err != nil { \tlog.Println(err) \t} \tdefault: \tw.WriteHeader(http.StatusBadRequest) \t_, _ = w.Write([]byte(\u0026#34;Invalid key\u0026#34;)) \tlog.Println(\u0026#34;Invalid key\u0026#34;) \t} } http.ResponseWriter 用于向任何连接的HTTP客户端发送响应\n设置相应标志头: w.WriteHeader(http.StatusOK) 获取或实则响应头 w.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Header().Add(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;) 写入相应数据: w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) 例子:\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  type SystemInfo struct { \tHostname string `json:\u0026#34;hostname\u0026#34;` \tUptime string `json:\u0026#34;uptime\u0026#34;` }  func rootHandler(w http.ResponseWriter, r *http.Request) { \tinfo := SystemInfo{ \tHostname: \u0026#34;test\u0026#34;, \tUptime: \u0026#34;2022-01-01 00:00:00\u0026#34;, \t} \tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) \tw.WriteHeader(http.StatusOK) \tbytes, _ := json.Marshal(info) \t_, err := w.Write(bytes) \tif err != nil { \tlog.Println(\u0026#34;Error writing response: \u0026#34;, err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } OSX MP16 ~ ❯ curl localhost:12345 {\u0026#34;hostname\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;uptime\u0026#34;:\u0026#34;2022-01-01 00:00:00\u0026#34;} *http.Request 指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如\n获取基本信息 func rootHandler(w http.ResponseWriter, r *http.Request) {  \tfmt.Println(\u0026#34;User Agent: \u0026#34;, r.UserAgent()) \tfmt.Println(\u0026#34;Host: \u0026#34;, r.Host) \tfmt.Println(\u0026#34;Remote Address: \u0026#34;, r.RemoteAddr) \tfmt.Println(\u0026#34;Request URI: \u0026#34;, r.RequestURI) \tfmt.Println(\u0026#34;Method: \u0026#34;, r.Method) \tfmt.Println(\u0026#34;URL: \u0026#34;, r.URL) \tfmt.Println(\u0026#34;Header: \u0026#34;, r.Header)  \tw.WriteHeader(http.StatusOK) } 输出:\nUser Agent: curl/7.79.1 Host: localhost:12345 Remote Address: 127.0.0.1:58967 Request URI: / Method: GET URL: / Header: map[Accept:[*/*] User-Agent:[curl/7.79.1]] 获取cookie func rootHandler(w http.ResponseWriter, r *http.Request) {  \t//获取所有 \tfor _, c := range r.Cookies() { \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value) \t}  \t//获取指定 \tc, err := r.Cookie(\u0026#34;token\u0026#34;) \tif err != nil { \tlog.Println(err) \t} \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value)  \tw.WriteHeader(http.StatusOK) } curl --cookie \u0026quot;token=abcdefg\u0026quot; http://localhost:12345\n获取GET参数   获取所有参数 args := r.URL.Query()\n  获取指定参数(注:参数可能被重复写多次)\n比如: localhost:12345/?id=5\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tids, ok := r.URL.Query()[\u0026#34;id\u0026#34;] \tif !ok || len(ids[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \treturn \t} \tid := ids[0] \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is: \u0026#34; + id)  \tw.WriteHeader(http.StatusOK) }   或者\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.FormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) }  也可以通过r.Form来获取Get参数\n 获取PATCH, POST or PUT参数 比如 curl -d \u0026quot;id=5\u0026amp;format=1\u0026quot; http://localhost:12345/\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t//parse \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \t//get post args \tfor k, v := range r.PostForm { \tlog.Println(\u0026#34;key:\u0026#34;, k) \tlog.Println(\u0026#34;val:\u0026#34;, v) // v []string \t}  \tw.WriteHeader(http.StatusOK) } 输出\n2022/06/06 15:14:46 key: id 2022/06/06 15:14:46 val: [5] 2022/06/06 15:14:46 key: format 2022/06/06 15:14:46 val: [1] ParseForm会填充r.Form和r.PostForm。 对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。 对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。 如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。 对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。 ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。\n r.Form属性包含了post表单和url中的get参数。\nr.PostForm属性只包含了post表单参数。\n 获取指定参数, 比如\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \tids := r.PostForm.Get(\u0026#34;id\u0026#34;) //获取id参数的第一个值 \tlog.Println(\u0026#34;id:\u0026#34;, ids)  \tw.WriteHeader(http.StatusOK) } 或者\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.PostFormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) } 获取上传文件 比如 curl -F \u0026quot;file=@IMG_1526.PNG;type=image/png\u0026quot; http://localhost:12345/upload\n下面代码中:\nr.ParseMultipartForm(10 \u0026lt;\u0026lt; 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响.\nFormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。\npackage main  import ( \t\u0026#34;io\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;mime/multipart\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; )  func uploadHandler(w http.ResponseWriter, r *http.Request) {  \t// Parse the multipart form in the request \terr := r.ParseMultipartForm(10 \u0026lt;\u0026lt; 20) // 10 MiB \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \t\t\t// FormFile returns the first file for the given key `file` \t// it also returns the FileHeader, so we can get the Filename, the Header and the size of the file \tfile, handler, err := r.FormFile(\u0026#34;file\u0026#34;) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(file multipart.File) { \terr := file.Close() \tif err != nil { \tlog.Println(err) \t} \t}(file) \terr = os.MkdirAll(\u0026#34;./upload\u0026#34;, 0777) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tlocalFile, err := os.OpenFile(\u0026#34;./upload/\u0026#34;+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(localFile *os.File) { \terr := localFile.Close() \tif err != nil { \tlog.Println(err) \t} \t}(localFile) \t_, err = io.Copy(localFile, file) \tif err != nil { \thttp.Error(w, \u0026#34;\u0026#34;, http.StatusInternalServerError)  return \t}  \tw.WriteHeader(http.StatusOK) }  func main() {  \thttp.HandleFunc(\u0026#34;/upload\u0026#34;, uploadHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } 👍各种获取参数方式比较    操作 解析 读取URL参数 读取Body表单 支持文本 支持二进制     r.Form r.ParseForm() Y Y Y    r.PostForm r.ParseForm()  Y Y    r.FormValue() 自动调用r.ParseForm() Y Y Y    r.PostFormValue() 自动调用r.ParseForm()  Y Y    r.MultipartForm ParseMultipartForm()  Y Y Y   r.FormFile 自动调用ParseMultipartForm()  Y  Y    Handler , Handle , HandleFunc 与 http.ListenAndServe 使用默认的Handler 先看一个简单的例子\npackage main  import \u0026#34;net/http\u0026#34;  func main() { \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello, world!\u0026#34;)) \t}) \thttp.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) \t})  \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) } 在启动一个HttpServer的时候, 其实我们就关心2个东西:\n 地址 路由: 将请求对应到相应的处理函数中去  这两个参数 在http.ListenAndServe(\u0026quot;:12345\u0026quot;, nil)中进行设置的, 第一个为地址, 第二个传递处理函数.\n如果传递nil, 则采用默认的\n The handler is typically nil, in which case the DefaultServeMux is used.\n http.ListenAndServe的实现如下:\nfunc ListenAndServe(addr string, handler Handler) error { \tserver := \u0026amp;Server{Addr: addr, Handler: handler} \treturn server.ListenAndServe() } type Handler interface {  ServeHTTP(ResponseWriter, *Request) } 可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler\n自定义Handler 定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法\n然后使用 Handle函数进行路由注册\npackage main  import \u0026#34;net/http\u0026#34;  type MyIndexHandler struct { }  func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello World\u0026#34;)) }  type MyBlogHandler struct { }  func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) }  func main() { \tmux := http.NewServeMux() \tmux.Handle(\u0026#34;/\u0026#34;, \u0026amp;MyIndexHandler{}) \tmux.Handle(\u0026#34;/blog\u0026#34;, \u0026amp;MyBlogHandler{}) \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } OSX MP16 ~ ❯ curl localhost:12345 Hello World OSX MP16 ~ ❯ curl localhost:12345/blog This is my Blog OSX MP16 ~ ❯ 但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱\n这时候就可以用mux.HandleFunc来实现路由\npackage main  import \u0026#34;net/http\u0026#34;  func main() {  mux := http.NewServeMux()  mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;Hello World\u0026#34;))  })  mux.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;This is my Blog\u0026#34;))  })   http.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } 自定义ServeMux 在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点\n比如, 其是通过url进行路由, 但不支持基于方法(GET, POST\u0026hellip;)的路由, 不支持正则表达式等等\n参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use\n人气Web框架 参考这篇文章,\nhttps://blog.51cto.com/coderaction/3001008\n其中有各框架的对比, 功能上iris最全\nhttps://github.com/kataras/iris\n","permalink":"/posts/golang_http_server/","summary":"简单的文件服务器 package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享.\n然后写一个函数放到bash.rc 或zshrc中\n#文件服务器 function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err !","title":"[Golang]Http Server"},{"content":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值.\n程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此.\n使用一个协程 如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢?\nfunc main() { \tadd(1000000) \tgo sub(1000000) \tshow() } 会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了.\n或许我们应该等到sub函数执行结束\n等待协程结束   错误的方式 如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如:\nfunc sub(count int, done *bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \t*done = true } //....  func main() { \tadd(1000000)  \tdone := false \tgo sub(1000000, \u0026amp;done)  \tfor !done { \ttime.Sleep(time.Millisecond * 10) \t}  \tshow() } 这虽然也能得到正确的输出, 但非常不优雅.\n  正确的方式1 可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag\n//... func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tdone \u0026lt;- true } //.... func main() { \tadd(1000000)  \tdone := make(chan bool) \tgo sub(1000000, done) \t\u0026lt;-subDone \tshow() } 这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达. 所以 \u0026lt;-subDone 会一直阻塞, 直到通过subDone \u0026lt;- true向其中写入了数据\n  使用2个协程 上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢\n很容易想到, 使用两次\u0026lt;-done 也就是说向信道索要两个计算完成的标志, add和 sub 计算完成后分别向其中放入标志.\npackage main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\u0026quot;sub done\u0026quot;)这样的输出\n运行程序, 得到\nadd done sub done 824933 Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0\n再运行一次, 得到:\nsub done add done -481342 原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现**\u0026ldquo;竞态\u0026rdquo;**\n竞态 有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的\n如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的.\n相反, 并发不安全的代码,可能会出现死锁,活锁,竞态\n竞态则表示代码可执行,但可能出现结果不一致(错误结果)\n###解决方法1, 利用信道\nfunc main() { \tdone := make(chan bool) \tgo add(1000000, done) \t\u0026lt;-done //1 \tgo sub(1000000, done) \t\u0026lt;-done //2 \tshow() } 在add执行完毕之前, 首先会堵塞在//1处,\nfunc add(count int, done chan bool) { \t//.... \tdone \u0026lt;- true } add函数执行最后一句 done \u0026lt;- true 后 \u0026lt;-done //1能取到值, 接触阻塞. 然后继续往下执行sub函数.\n这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行.\n解决方法2, 利用 Mutex 或 RWMutex sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问).\nmutex := \u0026amp;sync.Mutex{}  mutex.Lock() //.... 更新共享变量 mutex.Unlock() 注意: 在官方文档中有这么一句 \u0026ldquo;Values containing the types defined in this package should not be copied.\u0026rdquo; (\u0026ldquo;包含这个包中定义的类型的值不应该被复制。\u0026rdquo;) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递.\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; )  var ( \tsharedCounter = 0 \tmutex = \u0026amp;sync.Mutex{} )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter++ \tmutex.Unlock() \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter-- \tmutex.Unlock() \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 在读写sharedCounter之前先Lock(), 用完后Unlock()\n如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度)\nfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tfmt.Println(\u0026#34;--\u0026#34;) // fmt.Println(\u0026#34;++\u0026#34;) \tsharedCounter-- // sharedCounter++ \tmutex.Unlock() \t} 则可以看到 ++ 和 \u0026ndash; 是交叉着打印的, 说明是并行执行的.\n另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外, 其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高\n解决方法3, 利用原子操作 原子操作在\u0026quot;sync/atomic\u0026quot;包中. 利用这个包中提供的函数可实现\u0026quot;无锁版\u0026quot;的共享变量读写\n原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync/atomic\u0026#34; )  var ( \tsharedCounter = int64(0) )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, 1) // \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, -1) // \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 原子操作的常用接口如下(以int32为例)\n//将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)   //使用原子操作,将addr指向的位置增加一个delta func AddInt32(addr *int32, delta int32) (new int32)  //原子读取 //当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。 func LoadInt32(addr *int32) (val int32)  //读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包 func StoreInt32(addr *int32, val int32)   //此类型的值相当于一个容器，可以被用来“原子地\u0026#34;存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。 //有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。 // A Value must not be copied after first use. type Value struct { \tv interface{} }  原子操作与互斥锁的区别\n首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。\n原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。\n下面是几点区别：\n 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作 原子操作是无锁的，常常直接通过CPU指令直接实现 原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程    不要轻易使用atomic\nhttps://texlution.com/post/golang-lock-free-values-with-atomic-value/\n 其它并发控制方法 上面的例子中, 我们都是使用的信道来进行并发控制 (done \u0026lt;- true与\u0026lt;-done), 这只是常用的方法之一\nWaitGroup sync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。\n要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;sync\u0026#34;  \u0026#34;sync/atomic\u0026#34; )  var (  sharedCounter = int64(0) )  func add(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, 1)  }   fmt.Println(\u0026#34;add done\u0026#34;)  wg.Done() }  func sub(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, -1)  }  fmt.Println(\u0026#34;sub done\u0026#34;)  wg.Done() }  func show() {  fmt.Println(sharedCounter) }  func main() {  wg := sync.WaitGroup{}  wg.Add(2)   go add(1000000, \u0026amp;wg)  go sub(1000000, \u0026amp;wg)   wg.Wait()  show() } 注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup)\ncontext.Context Context提供了2个功能\n 控制子协程结束 传递值  其不在sync包中, 后面专门讲\nsync.Pool 对象复用 其提供一个\u0026quot;并发安全\u0026quot;的可复用的对象池. 用来减少频繁GC所代理的压力.\n其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个\n参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html\n以及这里 https://geektutu.com/post/hpg-sync-pool.html\n在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则:\n 根据你收集到的需求设计你的代码（不要跳过这个步骤）。 编写最简单、最清晰、最愚蠢的设计实现。 如果客户满意，就停止 如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。 解决最高性能的主导者 剖析并进入第五阶段。然后进入3 如果实在搞不定, 再想想sync.Pool  sync.Once 只执行一次 sync.Once 提供了一种方法, 让相关代码只被执行一次\n实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦.\npackage lowLevelApi  import \u0026#34;fmt\u0026#34;  func InitEnv() { \tfmt.Println(\u0026#34;init environment\u0026#34;) }  func LedOn() { \tfmt.Println(\u0026#34;LedOn\u0026#34;) }  func LedOff() { \tfmt.Println(\u0026#34;LedOff\u0026#34;) } 其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧?\n因为他们的代码通常会这样写:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;goplayground/lowLevelApi\u0026#34; )  func turnLedOn() { \tfmt.Println(\u0026#34;Turning LED on\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOn() \tfmt.Println(\u0026#34;LED on\u0026#34;) }  func turnLedOff() { \tfmt.Println(\u0026#34;Turning LED off\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOff() \tfmt.Println(\u0026#34;LED off\u0026#34;) }  func main() { \tturnLedOn() \tturnLedOff() } 上面的代码会输出\nTurning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off 为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Once\nvar ( \tonce sync.Once )  func InitEnv() { \tonce.Do(func() { \tfmt.Println(\u0026#34;InitEnv\u0026#34;) \t}) } 这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次\nTurning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。\n init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。  sync.Cond 条件变量 sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒.\n下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态, 当准备好后, 将通知 Add和Sub继续向下执行\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; \t\u0026#34;time\u0026#34; )  var ( \tsharedCounter int )  func InitEnv(c *sync.Cond) { \tfmt.Println(\u0026#34;begin InitEnv\u0026#34;) \ttime.Sleep(time.Second * 1) \tc.L.Lock() \tsharedCounter = 10 \tc.L.Unlock() \tfmt.Println(\u0026#34;Init Env Done, broadcast...\u0026#34;) \tc.Broadcast() }  func Add(cout int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter += cout \tc.L.Unlock() \tfmt.Println(\u0026#34;Add Done\u0026#34;) }  func Sub(count int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter -= count \tc.L.Unlock() \tfmt.Println(\u0026#34;Sub Done\u0026#34;) }  func main() { \tcond := sync.NewCond(\u0026amp;sync.Mutex{}) \tgo InitEnv(cond) \tgo Add(5, cond) \tgo Sub(2, cond)  \ttime.Sleep(2 * time.Second) \tfmt.Println(\u0026#34;Final Counter:\u0026#34;, sharedCounter) } 输出\nbegin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()唤醒所有等待的协程, 另外还有一个Signal()方法, 用于唤醒一个协程. sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了\nsync.Map 内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本\n可以参考这篇文章 https://juejin.cn/post/6844903895227957262\n","permalink":"/posts/go_talk_about_sync/","summary":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器.","title":"[Golang]聊聊sync"},{"content":"前两天在一个项目中需要实现这样一个功能\u0026quot;点击一个按钮或通过API来重启后台服务\u0026quot;\n发现Github上有一个叫overseer的模块, 试用了一下,效果还不错\n使用方法很简单\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, 回车键重启APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } 项目地址: https://github.com/jpillora/overseer\n其README中介绍了如何使用这个模块来优雅地进行自我升级.\n","permalink":"/posts/golang_overseer_restart_app/","summary":"前两天在一个项目中需要实现这样一个功能\u0026quot;点击一个按钮或通过API来重启后台服务\u0026quot;\n发现Github上有一个叫overseer的模块, 试用了一下,效果还不错\n使用方法很简单\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, 回车键重启APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } 项目地址: https://github.com/jpillora/overseer\n其README中介绍了如何使用这个模块来优雅地进行自我升级.","title":"[Golang] 使用overseer实现APP重启"},{"content":"第1步：在Github上新建一个项目 登录你的Github账号，按照向导 新建一个 Repository\n假设你新建的Repo为： https://github.com/yourUserName/MyBlog.git\n第2步： Clone项目到本地并尝试push git clone https://github.com/yourUserName/MyBlog.git 尝试新建一个文件和push\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main 尝试提交的时候，会让你输入github账号和token（gitbub弃用了密码登录，而是使用token）\n如果你还没有生成过token，可以到Github你账户下的settings -\u0026gt; Developer settings 下生成token\n第3步：使用hugo自动生成静态网站  安装hugo  brew install hugo   按照官方教程新建一个网站 官方教程： https://gohugo.io/getting-started/quick-start/\n假设你的网站名称叫MySite\n  编译你的网站 hugo -D ，编译出来的静态网页的全部内容在MySite/public目录下\n  在本地运行试试 hugo server -D , 不出意外，你应该能在http://localhost:1313上看到你的站点\n  第4步：使用 fleek来将其自动部署到IPFS上   关联Github repo和fleek\n按照https://docs.ipfs.io/how-to/websites-on-ipfs/introducing-fleek/#host-a-site 教程一步步地将你的Github项目，也就是上面的MyBlog.git和fleek项目关联起来，这样，但你的git有更新后，fleek会将你的内容自动部署到IPFS上\nfleek给你的临时子域名，就在项目的下方，类似 xxxxxx.on.fleek.co , 你可以跳过教程中的Domain names一节\n  将hugo编译出的public下所有内容复制到本地的MyBlog下\n然后进行push\ncd MySite hugo -D cp -rf ./public/ ../MyBlog/ cd ../MyBlog git add . git commit -m \u0026#34;your comments\u0026#34; git push origin main push成功后，稍等2分钟，让fleek自动拉取你最新的内容并重新部署\n  第5步 makefile 我们使用makefile来让新建Blog文章、测试和发布显得自动化一些\ncd MySite touch Makefile vim Makefile 在Makefile中加入类似下面的内容：\nall: \thugo -D \ttest: # To ignore errors in a command line, # write a - at the beginning of the line\u0026#39;s text (after the initial tab). # The - is discarded before the command is passed to the shell for execution \t-killall -9 hugo \thugo server -D \u0026amp; \tsleep 2 \topen http://localhost:1313/ \trelease: \thugo -D \tcp -rf ./public/ ../MyBlog/ \tcd ../MyBlog/ \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;auto updated by script\u0026#34; \u0026amp;\u0026amp; git push origin main \t##how to use: # make new file=this_is_one_article.md new: \thugo new posts/$(file) \topen ./content/posts/$(file) \u0026amp; 大功告成 ","permalink":"/posts/how_to_create_this_blog/","summary":"第1步：在Github上新建一个项目 登录你的Github账号，按照向导 新建一个 Repository\n假设你新建的Repo为： https://github.com/yourUserName/MyBlog.git\n第2步： Clone项目到本地并尝试push git clone https://github.com/yourUserName/MyBlog.git 尝试新建一个文件和push\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main 尝试提交的时候，会让你输入github账号和token（gitbub弃用了密码登录，而是使用token）\n如果你还没有生成过token，可以到Github你账户下的settings -\u0026gt; Developer settings 下生成token\n第3步：使用hugo自动生成静态网站  安装hugo  brew install hugo   按照官方教程新建一个网站 官方教程： https://gohugo.io/getting-started/quick-start/\n假设你的网站名称叫MySite\n  编译你的网站 hugo -D ，编译出来的静态网页的全部内容在MySite/public目录下\n  在本地运行试试 hugo server -D , 不出意外，你应该能在http://localhost:1313上看到你的站点","title":"如何利用IFPS创建这个博客"},{"content":"关于这个BLOG： 这个BLOG的所有内容均存储在IPFS链上。\n同时在Github上也有对应副本： https://github.com/jack0x001/ChainBlog.git 。\n我使用了gohugo来自动生成网站 并使用 fleek来将其自动部署到IPFS上， 这样我就可以将精力放在网站内容本身上了。\n","permalink":"/posts/welcome/","summary":"关于这个BLOG： 这个BLOG的所有内容均存储在IPFS链上。\n同时在Github上也有对应副本： https://github.com/jack0x001/ChainBlog.git 。\n我使用了gohugo来自动生成网站 并使用 fleek来将其自动部署到IPFS上， 这样我就可以将精力放在网站内容本身上了。","title":"Welcome"}]