[{"content":"简单的文件服务器 package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享.\n然后写一个函数放到bash.rc 或zshrc中\n#文件服务器 function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err != nil { log.Fatal(err) } } EOF } OSX MP16 ~/Downloads ❯ fileserver start file server :12345 Python中有相同的功能\npython3 -m SimpleHTTPServer 7777 或 python3 -m http.server\n一个简单的WebServer package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;Hello World!\\n\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} \t})  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } 访问一下试试:\nOSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345 Hello World! http.HandleFunc http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t//... \t}) 该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;\u0026lt;h1 style=\\\u0026#34;color:Tomato;\\\u0026#34;\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  //... } 函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息\n比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequest\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tkeys, ok := r.URL.Query()[\u0026#34;key\u0026#34;] \tif !ok || len(keys[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;) \tw.WriteHeader(http.StatusBadRequest) \t_, err := w.Write([]byte(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;)) \tif err != nil { \tlog.Println(err) \treturn \t} \treturn \t}  \tkey := keys[0] \tswitch key { \tcase \u0026#34;date\u0026#34;: \tw.WriteHeader(http.StatusOK) \t_, err := w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) \tif err != nil { \tlog.Println(err) \t} \tdefault: \tw.WriteHeader(http.StatusBadRequest) \t_, _ = w.Write([]byte(\u0026#34;Invalid key\u0026#34;)) \tlog.Println(\u0026#34;Invalid key\u0026#34;) \t} } http.ResponseWriter 用于向任何连接的HTTP客户端发送响应\n设置相应标志头: w.WriteHeader(http.StatusOK) 获取或实则响应头 w.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Header().Add(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;) 写入相应数据: w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) 例子:\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  type SystemInfo struct { \tHostname string `json:\u0026#34;hostname\u0026#34;` \tUptime string `json:\u0026#34;uptime\u0026#34;` }  func rootHandler(w http.ResponseWriter, r *http.Request) { \tinfo := SystemInfo{ \tHostname: \u0026#34;test\u0026#34;, \tUptime: \u0026#34;2022-01-01 00:00:00\u0026#34;, \t} \tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) \tw.WriteHeader(http.StatusOK) \tbytes, _ := json.Marshal(info) \t_, err := w.Write(bytes) \tif err != nil { \tlog.Println(\u0026#34;Error writing response: \u0026#34;, err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } OSX MP16 ~ ❯ curl localhost:12345 {\u0026#34;hostname\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;uptime\u0026#34;:\u0026#34;2022-01-01 00:00:00\u0026#34;} *http.Request 指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如\n获取基本信息 func rootHandler(w http.ResponseWriter, r *http.Request) {  \tfmt.Println(\u0026#34;User Agent: \u0026#34;, r.UserAgent()) \tfmt.Println(\u0026#34;Host: \u0026#34;, r.Host) \tfmt.Println(\u0026#34;Remote Address: \u0026#34;, r.RemoteAddr) \tfmt.Println(\u0026#34;Request URI: \u0026#34;, r.RequestURI) \tfmt.Println(\u0026#34;Method: \u0026#34;, r.Method) \tfmt.Println(\u0026#34;URL: \u0026#34;, r.URL) \tfmt.Println(\u0026#34;Header: \u0026#34;, r.Header)  \tw.WriteHeader(http.StatusOK) } 输出:\nUser Agent: curl/7.79.1 Host: localhost:12345 Remote Address: 127.0.0.1:58967 Request URI: / Method: GET URL: / Header: map[Accept:[*/*] User-Agent:[curl/7.79.1]] 获取cookie func rootHandler(w http.ResponseWriter, r *http.Request) {  \t//获取所有 \tfor _, c := range r.Cookies() { \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value) \t}  \t//获取指定 \tc, err := r.Cookie(\u0026#34;token\u0026#34;) \tif err != nil { \tlog.Println(err) \t} \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value)  \tw.WriteHeader(http.StatusOK) } curl --cookie \u0026quot;token=abcdefg\u0026quot; http://localhost:12345\n获取GET参数   获取所有参数 args := r.URL.Query()\n  获取指定参数(注:参数可能被重复写多次)\n比如: localhost:12345/?id=5\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tids, ok := r.URL.Query()[\u0026#34;id\u0026#34;] \tif !ok || len(ids[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \treturn \t} \tid := ids[0] \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is: \u0026#34; + id)  \tw.WriteHeader(http.StatusOK) }   或者\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.FormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) }  也可以通过r.Form来获取Get参数\n 获取PATCH, POST or PUT参数 比如 curl -d \u0026quot;id=5\u0026amp;format=1\u0026quot; http://localhost:12345/\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t//parse \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \t//get post args \tfor k, v := range r.PostForm { \tlog.Println(\u0026#34;key:\u0026#34;, k) \tlog.Println(\u0026#34;val:\u0026#34;, v) // v []string \t}  \tw.WriteHeader(http.StatusOK) } 输出\n2022/06/06 15:14:46 key: id 2022/06/06 15:14:46 val: [5] 2022/06/06 15:14:46 key: format 2022/06/06 15:14:46 val: [1] ParseForm会填充r.Form和r.PostForm。 对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。 对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。 如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。 对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。 ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。\n r.Form属性包含了post表单和url中的get参数。\nr.PostForm属性只包含了post表单参数。\n 获取指定参数, 比如\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \tids := r.PostForm.Get(\u0026#34;id\u0026#34;) //获取id参数的第一个值 \tlog.Println(\u0026#34;id:\u0026#34;, ids)  \tw.WriteHeader(http.StatusOK) } 或者\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.PostFormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) } 获取上传文件 比如 curl -F \u0026quot;file=@IMG_1526.PNG;type=image/png\u0026quot; http://localhost:12345/upload\n下面代码中:\nr.ParseMultipartForm(10 \u0026lt;\u0026lt; 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响.\nFormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。\npackage main  import ( \t\u0026#34;io\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;mime/multipart\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; )  func uploadHandler(w http.ResponseWriter, r *http.Request) {  \t// Parse the multipart form in the request \terr := r.ParseMultipartForm(10 \u0026lt;\u0026lt; 20) // 10 MiB \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \t\t\t// FormFile returns the first file for the given key `file` \t// it also returns the FileHeader, so we can get the Filename, the Header and the size of the file \tfile, handler, err := r.FormFile(\u0026#34;file\u0026#34;) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(file multipart.File) { \terr := file.Close() \tif err != nil { \tlog.Println(err) \t} \t}(file) \terr = os.MkdirAll(\u0026#34;./upload\u0026#34;, 0777) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tlocalFile, err := os.OpenFile(\u0026#34;./upload/\u0026#34;+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(localFile *os.File) { \terr := localFile.Close() \tif err != nil { \tlog.Println(err) \t} \t}(localFile) \t_, err = io.Copy(localFile, file) \tif err != nil { \thttp.Error(w, \u0026#34;\u0026#34;, http.StatusInternalServerError)  return \t}  \tw.WriteHeader(http.StatusOK) }  func main() {  \thttp.HandleFunc(\u0026#34;/upload\u0026#34;, uploadHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } 👍各种获取参数方式比较    操作 解析 读取URL参数 读取Body表单 支持文本 支持二进制     r.Form r.ParseForm() Y Y Y    r.PostForm r.ParseForm()  Y Y    r.FormValue() 自动调用r.ParseForm() Y Y Y    r.PostFormValue() 自动调用r.ParseForm()  Y Y    r.MultipartForm ParseMultipartForm()  Y Y Y   r.FormFile 自动调用ParseMultipartForm()  Y  Y    Handler , Handle , HandleFunc 与 http.ListenAndServe 使用默认的Handler 先看一个简单的例子\npackage main  import \u0026#34;net/http\u0026#34;  func main() { \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello, world!\u0026#34;)) \t}) \thttp.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) \t})  \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) } 在启动一个HttpServer的时候, 其实我们就关心2个东西:\n 地址 路由: 将请求对应到相应的处理函数中去  这两个参数 在http.ListenAndServe(\u0026quot;:12345\u0026quot;, nil)中进行设置的, 第一个为地址, 第二个传递处理函数.\n如果传递nil, 则采用默认的\n The handler is typically nil, in which case the DefaultServeMux is used.\n http.ListenAndServe的实现如下:\nfunc ListenAndServe(addr string, handler Handler) error { \tserver := \u0026amp;Server{Addr: addr, Handler: handler} \treturn server.ListenAndServe() } type Handler interface {  ServeHTTP(ResponseWriter, *Request) } 可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler\n自定义Handler 定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法\n然后使用 Handle函数进行路由注册\npackage main  import \u0026#34;net/http\u0026#34;  type MyIndexHandler struct { }  func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello World\u0026#34;)) }  type MyBlogHandler struct { }  func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) }  func main() { \tmux := http.NewServeMux() \tmux.Handle(\u0026#34;/\u0026#34;, \u0026amp;MyIndexHandler{}) \tmux.Handle(\u0026#34;/blog\u0026#34;, \u0026amp;MyBlogHandler{}) \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } OSX MP16 ~ ❯ curl localhost:12345 Hello World OSX MP16 ~ ❯ curl localhost:12345/blog This is my Blog OSX MP16 ~ ❯ 但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱\n这时候就可以用mux.HandleFunc来实现路由\npackage main  import \u0026#34;net/http\u0026#34;  func main() {  mux := http.NewServeMux()  mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;Hello World\u0026#34;))  })  mux.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;This is my Blog\u0026#34;))  })   http.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } 自定义ServeMux 在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点\n比如, 其是通过url进行路由, 但不支持基于方法(GET, POST\u0026hellip;)的路由, 不支持正则表达式等等\n参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use\n人气Web框架 参考这篇文章,\nhttps://blog.51cto.com/coderaction/3001008\n其中有各框架的对比, 功能上iris最全\nhttps://github.com/kataras/iris\n","permalink":"/posts/golang_http_server/","summary":"简单的文件服务器 package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享.\n然后写一个函数放到bash.rc 或zshrc中\n#文件服务器 function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err !","title":"[Golang]Http Server"},{"content":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值.\n程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此.\n使用一个协程 如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢?\nfunc main() { \tadd(1000000) \tgo sub(1000000) \tshow() } 会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了.\n或许我们应该等到sub函数执行结束\n等待协程结束   错误的方式 如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如:\nfunc sub(count int, done *bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \t*done = true } //....  func main() { \tadd(1000000)  \tdone := false \tgo sub(1000000, \u0026amp;done)  \tfor !done { \ttime.Sleep(time.Millisecond * 10) \t}  \tshow() } 这虽然也能得到正确的输出, 但非常不优雅.\n  正确的方式1 可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag\n//... func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tdone \u0026lt;- true } //.... func main() { \tadd(1000000)  \tdone := make(chan bool) \tgo sub(1000000, done) \t\u0026lt;-subDone \tshow() } 这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达. 所以 \u0026lt;-subDone 会一直阻塞, 直到通过subDone \u0026lt;- true向其中写入了数据\n  使用2个协程 上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢\n很容易想到, 使用两次\u0026lt;-done 也就是说向信道索要两个计算完成的标志, add和 sub 计算完成后分别向其中放入标志.\npackage main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\u0026quot;sub done\u0026quot;)这样的输出\n运行程序, 得到\nadd done sub done 824933 Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0\n再运行一次, 得到:\nsub done add done -481342 原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现**\u0026ldquo;竞态\u0026rdquo;**\n竞态 有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的\n如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的.\n相反, 并发不安全的代码,可能会出现死锁,活锁,竞态\n竞态则表示代码可执行,但可能出现结果不一致(错误结果)\n###解决方法1, 利用信道\nfunc main() { \tdone := make(chan bool) \tgo add(1000000, done) \t\u0026lt;-done //1 \tgo sub(1000000, done) \t\u0026lt;-done //2 \tshow() } 在add执行完毕之前, 首先会堵塞在//1处,\nfunc add(count int, done chan bool) { \t//.... \tdone \u0026lt;- true } add函数执行最后一句 done \u0026lt;- true 后 \u0026lt;-done //1能取到值, 接触阻塞. 然后继续往下执行sub函数.\n这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行.\n解决方法2, 利用 Mutex 或 RWMutex sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问).\nmutex := \u0026amp;sync.Mutex{}  mutex.Lock() //.... 更新共享变量 mutex.Unlock() 注意: 在官方文档中有这么一句 \u0026ldquo;Values containing the types defined in this package should not be copied.\u0026rdquo; (\u0026ldquo;包含这个包中定义的类型的值不应该被复制。\u0026rdquo;) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递.\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; )  var ( \tsharedCounter = 0 \tmutex = \u0026amp;sync.Mutex{} )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter++ \tmutex.Unlock() \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter-- \tmutex.Unlock() \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 在读写sharedCounter之前先Lock(), 用完后Unlock()\n如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度)\nfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tfmt.Println(\u0026#34;--\u0026#34;) // fmt.Println(\u0026#34;++\u0026#34;) \tsharedCounter-- // sharedCounter++ \tmutex.Unlock() \t} 则可以看到 ++ 和 \u0026ndash; 是交叉着打印的, 说明是并行执行的.\n另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外, 其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高\n解决方法3, 利用原子操作 原子操作在\u0026quot;sync/atomic\u0026quot;包中. 利用这个包中提供的函数可实现\u0026quot;无锁版\u0026quot;的共享变量读写\n原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync/atomic\u0026#34; )  var ( \tsharedCounter = int64(0) )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, 1) // \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, -1) // \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } 原子操作的常用接口如下(以int32为例)\n//将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)   //使用原子操作,将addr指向的位置增加一个delta func AddInt32(addr *int32, delta int32) (new int32)  //原子读取 //当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。 func LoadInt32(addr *int32) (val int32)  //读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包 func StoreInt32(addr *int32, val int32)   //此类型的值相当于一个容器，可以被用来“原子地\u0026#34;存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。 //有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。 // A Value must not be copied after first use. type Value struct { \tv interface{} }  原子操作与互斥锁的区别\n首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。\n原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。\n下面是几点区别：\n 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作 原子操作是无锁的，常常直接通过CPU指令直接实现 原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程    不要轻易使用atomic\nhttps://texlution.com/post/golang-lock-free-values-with-atomic-value/\n 其它并发控制方法 上面的例子中, 我们都是使用的信道来进行并发控制 (done \u0026lt;- true与\u0026lt;-done), 这只是常用的方法之一\nWaitGroup sync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。\n要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;sync\u0026#34;  \u0026#34;sync/atomic\u0026#34; )  var (  sharedCounter = int64(0) )  func add(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, 1)  }   fmt.Println(\u0026#34;add done\u0026#34;)  wg.Done() }  func sub(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, -1)  }  fmt.Println(\u0026#34;sub done\u0026#34;)  wg.Done() }  func show() {  fmt.Println(sharedCounter) }  func main() {  wg := sync.WaitGroup{}  wg.Add(2)   go add(1000000, \u0026amp;wg)  go sub(1000000, \u0026amp;wg)   wg.Wait()  show() } 注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup)\ncontext.Context Context提供了2个功能\n 控制子协程结束 传递值  其不在sync包中, 后面专门讲\nsync.Pool 对象复用 其提供一个\u0026quot;并发安全\u0026quot;的可复用的对象池. 用来减少频繁GC所代理的压力.\n其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个\n参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html\n以及这里 https://geektutu.com/post/hpg-sync-pool.html\n在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则:\n 根据你收集到的需求设计你的代码（不要跳过这个步骤）。 编写最简单、最清晰、最愚蠢的设计实现。 如果客户满意，就停止 如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。 解决最高性能的主导者 剖析并进入第五阶段。然后进入3 如果实在搞不定, 再想想sync.Pool  sync.Once 只执行一次 sync.Once 提供了一种方法, 让相关代码只被执行一次\n实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦.\npackage lowLevelApi  import \u0026#34;fmt\u0026#34;  func InitEnv() { \tfmt.Println(\u0026#34;init environment\u0026#34;) }  func LedOn() { \tfmt.Println(\u0026#34;LedOn\u0026#34;) }  func LedOff() { \tfmt.Println(\u0026#34;LedOff\u0026#34;) } 其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧?\n因为他们的代码通常会这样写:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;goplayground/lowLevelApi\u0026#34; )  func turnLedOn() { \tfmt.Println(\u0026#34;Turning LED on\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOn() \tfmt.Println(\u0026#34;LED on\u0026#34;) }  func turnLedOff() { \tfmt.Println(\u0026#34;Turning LED off\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOff() \tfmt.Println(\u0026#34;LED off\u0026#34;) }  func main() { \tturnLedOn() \tturnLedOff() } 上面的代码会输出\nTurning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off 为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Once\nvar ( \tonce sync.Once )  func InitEnv() { \tonce.Do(func() { \tfmt.Println(\u0026#34;InitEnv\u0026#34;) \t}) } 这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次\nTurning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。\n init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。  sync.Cond 条件变量 sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒.\n下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态, 当准备好后, 将通知 Add和Sub继续向下执行\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; \t\u0026#34;time\u0026#34; )  var ( \tsharedCounter int )  func InitEnv(c *sync.Cond) { \tfmt.Println(\u0026#34;begin InitEnv\u0026#34;) \ttime.Sleep(time.Second * 1) \tc.L.Lock() \tsharedCounter = 10 \tc.L.Unlock() \tfmt.Println(\u0026#34;Init Env Done, broadcast...\u0026#34;) \tc.Broadcast() }  func Add(cout int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter += cout \tc.L.Unlock() \tfmt.Println(\u0026#34;Add Done\u0026#34;) }  func Sub(count int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter -= count \tc.L.Unlock() \tfmt.Println(\u0026#34;Sub Done\u0026#34;) }  func main() { \tcond := sync.NewCond(\u0026amp;sync.Mutex{}) \tgo InitEnv(cond) \tgo Add(5, cond) \tgo Sub(2, cond)  \ttime.Sleep(2 * time.Second) \tfmt.Println(\u0026#34;Final Counter:\u0026#34;, sharedCounter) } 输出\nbegin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()唤醒所有等待的协程, 另外还有一个Signal()方法, 用于唤醒一个协程. sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了\nsync.Map 内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本\n可以参考这篇文章 https://juejin.cn/post/6844903895227957262\n","permalink":"/posts/go_talk_about_sync/","summary":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器.","title":"[Golang]聊聊sync"},{"content":"前两天在一个项目中需要实现这样一个功能\u0026quot;点击一个按钮或通过API来重启后台服务\u0026quot;\n发现Github上有一个叫overseer的模块, 试用了一下,效果还不错\n使用方法很简单\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, 回车键重启APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } 项目地址: https://github.com/jpillora/overseer\n其README中介绍了如何使用这个模块来优雅地进行自我升级.\n","permalink":"/posts/golang_overseer_restart_app/","summary":"前两天在一个项目中需要实现这样一个功能\u0026quot;点击一个按钮或通过API来重启后台服务\u0026quot;\n发现Github上有一个叫overseer的模块, 试用了一下,效果还不错\n使用方法很简单\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, 回车键重启APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } 项目地址: https://github.com/jpillora/overseer\n其README中介绍了如何使用这个模块来优雅地进行自我升级.","title":"[Golang] 使用overseer实现APP重启"},{"content":"第1步：在Github上新建一个项目 登录你的Github账号，按照向导 新建一个 Repository\n假设你新建的Repo为： https://github.com/yourUserName/MyBlog.git\n第2步： Clone项目到本地并尝试push git clone https://github.com/yourUserName/MyBlog.git 尝试新建一个文件和push\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main 尝试提交的时候，会让你输入github账号和token（gitbub弃用了密码登录，而是使用token）\n如果你还没有生成过token，可以到Github你账户下的settings -\u0026gt; Developer settings 下生成token\n第3步：使用hugo自动生成静态网站  安装hugo  brew install hugo   按照官方教程新建一个网站 官方教程： https://gohugo.io/getting-started/quick-start/\n假设你的网站名称叫MySite\n  编译你的网站 hugo -D ，编译出来的静态网页的全部内容在MySite/public目录下\n  在本地运行试试 hugo server -D , 不出意外，你应该能在http://localhost:1313上看到你的站点\n  第4步：使用 fleek来将其自动部署到IPFS上   关联Github repo和fleek\n按照https://docs.ipfs.io/how-to/websites-on-ipfs/introducing-fleek/#host-a-site 教程一步步地将你的Github项目，也就是上面的MyBlog.git和fleek项目关联起来，这样，但你的git有更新后，fleek会将你的内容自动部署到IPFS上\nfleek给你的临时子域名，就在项目的下方，类似 xxxxxx.on.fleek.co , 你可以跳过教程中的Domain names一节\n  将hugo编译出的public下所有内容复制到本地的MyBlog下\n然后进行push\ncd MySite hugo -D cp -rf ./public/ ../MyBlog/ cd ../MyBlog git add . git commit -m \u0026#34;your comments\u0026#34; git push origin main push成功后，稍等2分钟，让fleek自动拉取你最新的内容并重新部署\n  第5步 makefile 我们使用makefile来让新建Blog文章、测试和发布显得自动化一些\ncd MySite touch Makefile vim Makefile 在Makefile中加入类似下面的内容：\nall: \thugo -D \ttest: # To ignore errors in a command line, # write a - at the beginning of the line\u0026#39;s text (after the initial tab). # The - is discarded before the command is passed to the shell for execution \t-killall -9 hugo \thugo server -D \u0026amp; \tsleep 2 \topen http://localhost:1313/ \trelease: \thugo -D \tcp -rf ./public/ ../MyBlog/ \tcd ../MyBlog/ \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;auto updated by script\u0026#34; \u0026amp;\u0026amp; git push origin main \t##how to use: # make new file=this_is_one_article.md new: \thugo new posts/$(file) \topen ./content/posts/$(file) \u0026amp; 大功告成 ","permalink":"/posts/how_to_create_this_blog/","summary":"第1步：在Github上新建一个项目 登录你的Github账号，按照向导 新建一个 Repository\n假设你新建的Repo为： https://github.com/yourUserName/MyBlog.git\n第2步： Clone项目到本地并尝试push git clone https://github.com/yourUserName/MyBlog.git 尝试新建一个文件和push\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main 尝试提交的时候，会让你输入github账号和token（gitbub弃用了密码登录，而是使用token）\n如果你还没有生成过token，可以到Github你账户下的settings -\u0026gt; Developer settings 下生成token\n第3步：使用hugo自动生成静态网站  安装hugo  brew install hugo   按照官方教程新建一个网站 官方教程： https://gohugo.io/getting-started/quick-start/\n假设你的网站名称叫MySite\n  编译你的网站 hugo -D ，编译出来的静态网页的全部内容在MySite/public目录下\n  在本地运行试试 hugo server -D , 不出意外，你应该能在http://localhost:1313上看到你的站点","title":"如何利用IFPS创建这个博客"},{"content":"关于这个BLOG： 这个BLOG的所有内容均存储在IPFS链上。\n同时在Github上也有对应副本： https://github.com/jack0x001/ChainBlog.git 。\n我使用了gohugo来自动生成网站 并使用 fleek来将其自动部署到IPFS上， 这样我就可以将精力放在网站内容本身上了。\n","permalink":"/posts/welcome/","summary":"关于这个BLOG： 这个BLOG的所有内容均存储在IPFS链上。\n同时在Github上也有对应副本： https://github.com/jack0x001/ChainBlog.git 。\n我使用了gohugo来自动生成网站 并使用 fleek来将其自动部署到IPFS上， 这样我就可以将精力放在网站内容本身上了。","title":"Welcome"}]