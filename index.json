[{"content":"ç®€å•çš„æ–‡ä»¶æœåŠ¡å™¨ package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } ä¸Šé¢è¿™ä¸ªä¾‹å­åˆ›å»ºäº†ä¸€ä¸ªä»¥å½“å‰ç›®å½•ä¸ºç«™ç‚¹è·Ÿç›®å½•çš„æ–‡ä»¶æœåŠ¡å™¨, æˆ‘ä¸€èˆ¬ç”¨è¿™ä¸ªæ¥ä½œä¸ºå±€åŸŸç½‘æ–‡ä»¶å…±äº«.\nç„¶åå†™ä¸€ä¸ªå‡½æ•°æ”¾åˆ°bash.rc æˆ–zshrcä¸­\n#æ–‡ä»¶æœåŠ¡å™¨ function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err != nil { log.Fatal(err) } } EOF } OSX MP16 ~/Downloads â¯ fileserver start file server :12345 Pythonä¸­æœ‰ç›¸åŒçš„åŠŸèƒ½\npython3 -m SimpleHTTPServer 7777 æˆ– python3 -m http.server\nä¸€ä¸ªç®€å•çš„WebServer package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;Hello World!\\n\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} \t})  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } è®¿é—®ä¸€ä¸‹è¯•è¯•:\nOSX MP16 ~/Downloads/goplayground â¯ curl http://localhost:12345 Hello World! http.HandleFunc http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \t//... \t}) è¯¥æ–¹æ³•æä¾›äº†ä¸€ç§æŒ‡å®šå¦‚ä½•å¤„ç†ç‰¹å®šè·¯ç”±çš„è¯·æ±‚çš„æ–¹æ³•, ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºè·¯ç”±, ç¬¬äºŒä¸ªå‚æ•°ä¸ºå¤„ç†å‡½æ•°. å¤„ç†å‡½æ•°å¯å†™æˆåŒ¿åå‡½æ•°, ä¹Ÿå¯ä»¥å£°æ˜ä¸ºä¸€ä¸ªç‹¬ç«‹çš„å‡½æ•°\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t_, err := w.Write([]byte(\u0026#34;\u0026lt;h1 style=\\\u0026#34;color:Tomato;\\\u0026#34;\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#34;)) \tif err != nil { \tlog.Println(err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  //... } å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯http.ResponseWriterç±»å‹çš„å€¼ã€‚è¿™æ˜¯ç”¨äºå‘ä»»ä½•è¿æ¥çš„HTTPå®¢æˆ·ç«¯å‘é€å“åº”çš„æœºåˆ¶ã€‚è¿™ä¹Ÿæ˜¯å“åº”æ ‡å¤´çš„è®¾ç½®æ–¹å¼,æ¯”å¦‚w.WriteHeader(http.StatusOK)ã€‚ç¬¬äºŒä¸ªè®ºç‚¹æ˜¯æŒ‡å‘http.Requestçš„æŒ‡é’ˆã€‚è¿™æ˜¯ä»ç½‘ç»œè¯·æ±‚ä¸­æ£€ç´¢æ•°æ®çš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥é€šè¿‡è¯·æ±‚æŒ‡é’ˆè®¿é—®è¡¨å•æäº¤çš„è¯¦ç»†ä¿¡æ¯\næ¯”å¦‚ ä¸‹é¢çš„æ–¹æ³•, ä½¿ç”¨ http://127.0.0.1:12345/?key=date æ—¶å°†è¿”å›å½“å‰çš„æ—¥æœŸ, ç¡®å®key=æˆ–keyä¸æ­£ç¡®æ—¶è¿”å›http.StatusBadRequest\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tkeys, ok := r.URL.Query()[\u0026#34;key\u0026#34;] \tif !ok || len(keys[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;) \tw.WriteHeader(http.StatusBadRequest) \t_, err := w.Write([]byte(\u0026#34;Url Param \u0026#39;key\u0026#39; is missing\u0026#34;)) \tif err != nil { \tlog.Println(err) \treturn \t} \treturn \t}  \tkey := keys[0] \tswitch key { \tcase \u0026#34;date\u0026#34;: \tw.WriteHeader(http.StatusOK) \t_, err := w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) \tif err != nil { \tlog.Println(err) \t} \tdefault: \tw.WriteHeader(http.StatusBadRequest) \t_, _ = w.Write([]byte(\u0026#34;Invalid key\u0026#34;)) \tlog.Println(\u0026#34;Invalid key\u0026#34;) \t} } http.ResponseWriter ç”¨äºå‘ä»»ä½•è¿æ¥çš„HTTPå®¢æˆ·ç«¯å‘é€å“åº”\nè®¾ç½®ç›¸åº”æ ‡å¿—å¤´: w.WriteHeader(http.StatusOK) è·å–æˆ–å®åˆ™å“åº”å¤´ w.Header().Set(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Header().Add(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;) å†™å…¥ç›¸åº”æ•°æ®: w.Write([]byte(time.Now().Format(\u0026#34;2006-01-02\u0026#34;))) ä¾‹å­:\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  type SystemInfo struct { \tHostname string `json:\u0026#34;hostname\u0026#34;` \tUptime string `json:\u0026#34;uptime\u0026#34;` }  func rootHandler(w http.ResponseWriter, r *http.Request) { \tinfo := SystemInfo{ \tHostname: \u0026#34;test\u0026#34;, \tUptime: \u0026#34;2022-01-01 00:00:00\u0026#34;, \t} \tw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) \tw.WriteHeader(http.StatusOK) \tbytes, _ := json.Marshal(info) \t_, err := w.Write(bytes) \tif err != nil { \tlog.Println(\u0026#34;Error writing response: \u0026#34;, err) \t} }  func main() {  \thttp.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } OSX MP16 ~ â¯ curl localhost:12345 {\u0026#34;hostname\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;uptime\u0026#34;:\u0026#34;2022-01-01 00:00:00\u0026#34;} *http.Request æŒ‡å‘http.Requestçš„æŒ‡é’ˆ, é€šè¿‡æ”¹æŒ‡é’ˆå¯ä»¥è·å–è¯·æ±‚ä¸­çš„å„ç§æ•°æ®, æ¯”å¦‚\nè·å–åŸºæœ¬ä¿¡æ¯ func rootHandler(w http.ResponseWriter, r *http.Request) {  \tfmt.Println(\u0026#34;User Agent: \u0026#34;, r.UserAgent()) \tfmt.Println(\u0026#34;Host: \u0026#34;, r.Host) \tfmt.Println(\u0026#34;Remote Address: \u0026#34;, r.RemoteAddr) \tfmt.Println(\u0026#34;Request URI: \u0026#34;, r.RequestURI) \tfmt.Println(\u0026#34;Method: \u0026#34;, r.Method) \tfmt.Println(\u0026#34;URL: \u0026#34;, r.URL) \tfmt.Println(\u0026#34;Header: \u0026#34;, r.Header)  \tw.WriteHeader(http.StatusOK) } è¾“å‡º:\nUser Agent: curl/7.79.1 Host: localhost:12345 Remote Address: 127.0.0.1:58967 Request URI: / Method: GET URL: / Header: map[Accept:[*/*] User-Agent:[curl/7.79.1]] è·å–cookie func rootHandler(w http.ResponseWriter, r *http.Request) {  \t//è·å–æ‰€æœ‰ \tfor _, c := range r.Cookies() { \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value) \t}  \t//è·å–æŒ‡å®š \tc, err := r.Cookie(\u0026#34;token\u0026#34;) \tif err != nil { \tlog.Println(err) \t} \tfmt.Printf(\u0026#34;%s : %q\\n\u0026#34;, c.Name, c.Value)  \tw.WriteHeader(http.StatusOK) } curl --cookie \u0026quot;token=abcdefg\u0026quot; http://localhost:12345\nè·å–GETå‚æ•°   è·å–æ‰€æœ‰å‚æ•° args := r.URL.Query()\n  è·å–æŒ‡å®šå‚æ•°(æ³¨:å‚æ•°å¯èƒ½è¢«é‡å¤å†™å¤šæ¬¡)\næ¯”å¦‚: localhost:12345/?id=5\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \tids, ok := r.URL.Query()[\u0026#34;id\u0026#34;] \tif !ok || len(ids[0]) \u0026lt; 1 { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \treturn \t} \tid := ids[0] \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is: \u0026#34; + id)  \tw.WriteHeader(http.StatusOK) }   æˆ–è€…\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.FormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) }  ä¹Ÿå¯ä»¥é€šè¿‡r.Formæ¥è·å–Getå‚æ•°\n è·å–PATCH, POST or PUTå‚æ•° æ¯”å¦‚ curl -d \u0026quot;id=5\u0026amp;format=1\u0026quot; http://localhost:12345/\nfunc rootHandler(w http.ResponseWriter, r *http.Request) { \t//parse \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \t//get post args \tfor k, v := range r.PostForm { \tlog.Println(\u0026#34;key:\u0026#34;, k) \tlog.Println(\u0026#34;val:\u0026#34;, v) // v []string \t}  \tw.WriteHeader(http.StatusOK) } è¾“å‡º\n2022/06/06 15:14:46 key: id 2022/06/06 15:14:46 val: [5] 2022/06/06 15:14:46 key: format 2022/06/06 15:14:46 val: [1] ParseFormä¼šå¡«å……r.Formå’Œr.PostFormã€‚ å¯¹äºæ‰€æœ‰çš„è¯·æ±‚ï¼ŒParseFormè§£ææ¥è‡ªURLçš„åŸå§‹æŸ¥è¯¢å¹¶æ›´æ–°r.Formã€‚ å¯¹äºPOSTã€PUTå’ŒPATCHè¯·æ±‚ï¼Œå®ƒä¹Ÿè¯»å–è¯·æ±‚æ­£æ–‡ï¼Œå°†å…¶è§£æä¸ºä¸€ä¸ªè¡¨å•ï¼Œå¹¶å°†ç»“æœæ”¾å…¥r.PostFormå’Œr.Formä¸­ã€‚åœ¨r.Formä¸­ï¼Œè¯·æ±‚æ­£æ–‡å‚æ•°ä¼˜å…ˆäºURLæŸ¥è¯¢å­—ç¬¦ä¸²å€¼ã€‚ å¦‚æœè¯·æ±‚ä½“çš„å¤§å°è¿˜æ²¡æœ‰è¢«MaxBytesReaderé™åˆ¶ï¼Œé‚£ä¹ˆå…¶å¤§å°å°†è¢«é™åˆ¶åœ¨10MBã€‚ å¯¹äºå…¶ä»–HTTPæ–¹æ³•ï¼Œæˆ–è€…å½“å†…å®¹ç±»å‹ä¸æ˜¯application/x-www-form-urlencodedæ—¶ï¼Œè¯·æ±‚æ­£æ–‡ä¸è¢«è¯»å–ï¼Œå¹¶ä¸”r.PostFormè¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªéé›¶çš„ç©ºå€¼ã€‚ ParseMultipartFormè‡ªåŠ¨è°ƒç”¨ParseFormã€‚ParseFormæ˜¯å¹‚ç­‰çš„ã€‚\n r.Formå±æ€§åŒ…å«äº†postè¡¨å•å’Œurlä¸­çš„getå‚æ•°ã€‚\nr.PostFormå±æ€§åªåŒ…å«äº†postè¡¨å•å‚æ•°ã€‚\n è·å–æŒ‡å®šå‚æ•°, æ¯”å¦‚\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \terr := r.ParseForm() \tif err != nil { \tlog.Println(\u0026#34;ParseForm error:\u0026#34;, err) \t} \tids := r.PostForm.Get(\u0026#34;id\u0026#34;) //è·å–idå‚æ•°çš„ç¬¬ä¸€ä¸ªå€¼ \tlog.Println(\u0026#34;id:\u0026#34;, ids)  \tw.WriteHeader(http.StatusOK) } æˆ–è€…\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {  \tid := r.PostFormValue(\u0026#34;id\u0026#34;) \tif id == \u0026#34;\u0026#34; { \tlog.Println(\u0026#34;Url Param \u0026#39;id\u0026#39; is missing\u0026#34;) \t} \tfmt.Println(\u0026#34;id:\u0026#34;, id)  \tw.WriteHeader(http.StatusOK) } è·å–ä¸Šä¼ æ–‡ä»¶ æ¯”å¦‚ curl -F \u0026quot;file=@IMG_1526.PNG;type=image/png\u0026quot; http://localhost:12345/upload\nä¸‹é¢ä»£ç ä¸­:\nr.ParseMultipartForm(10 \u0026lt;\u0026lt; 20)å°†ä¸€ä¸ªè¯·æ±‚ä½“è§£æä¸ºmultipart/form-dataã€‚æ•´ä¸ªè¯·æ±‚æ­£æ–‡è¢«è§£æï¼Œå¹¶ä¸”å…¶æ–‡ä»¶éƒ¨åˆ†æœ€å¤šå­˜å‚¨åœ¨maxMemoryå­—èŠ‚çš„å†…å­˜ä¸­ï¼Œå…¶ä½™éƒ¨åˆ†åˆ™å­˜å‚¨åœ¨ç£ç›˜çš„ä¸´æ—¶æ–‡ä»¶ä¸­ã€‚ParseMultipartFormåœ¨å¿…è¦æ—¶è°ƒç”¨ParseFormã€‚å¦‚æœParseFormè¿”å›ä¸€ä¸ªé”™è¯¯ï¼ŒParseMultipartFormå°†å…¶è¿”å›ï¼Œä½†ä¹Ÿç»§ç»­è§£æè¯·æ±‚æ­£æ–‡ã€‚åœ¨å¯¹ParseMultipartFormè¿›è¡Œä¸€æ¬¡è°ƒç”¨åï¼Œéšåçš„è°ƒç”¨æ²¡æœ‰ä»»ä½•å½±å“.\nFormFile è¿”å›æä¾›çš„è¡¨å•keyçš„ç¬¬ä¸€ä¸ªæ–‡ä»¶ã€‚å¦‚æœéœ€è¦ï¼ŒFormFileä¼šè°ƒç”¨ParseMultipartFormå’ŒParseFormã€‚\npackage main  import ( \t\u0026#34;io\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;mime/multipart\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; )  func uploadHandler(w http.ResponseWriter, r *http.Request) {  \t// Parse the multipart form in the request \terr := r.ParseMultipartForm(10 \u0026lt;\u0026lt; 20) // 10 MiB \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \t\t\t// FormFile returns the first file for the given key `file` \t// it also returns the FileHeader, so we can get the Filename, the Header and the size of the file \tfile, handler, err := r.FormFile(\u0026#34;file\u0026#34;) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(file multipart.File) { \terr := file.Close() \tif err != nil { \tlog.Println(err) \t} \t}(file) \terr = os.MkdirAll(\u0026#34;./upload\u0026#34;, 0777) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tlocalFile, err := os.OpenFile(\u0026#34;./upload/\u0026#34;+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666) \tif err != nil { \thttp.Error(w, err.Error(), http.StatusInternalServerError) \treturn \t} \tdefer func(localFile *os.File) { \terr := localFile.Close() \tif err != nil { \tlog.Println(err) \t} \t}(localFile) \t_, err = io.Copy(localFile, file) \tif err != nil { \thttp.Error(w, \u0026#34;\u0026#34;, http.StatusInternalServerError)  return \t}  \tw.WriteHeader(http.StatusOK) }  func main() {  \thttp.HandleFunc(\u0026#34;/upload\u0026#34;, uploadHandler)  \terr := http.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) \tif err != nil { \tlog.Fatal(err) \t} } ğŸ‘å„ç§è·å–å‚æ•°æ–¹å¼æ¯”è¾ƒ    æ“ä½œ è§£æ è¯»å–URLå‚æ•° è¯»å–Bodyè¡¨å• æ”¯æŒæ–‡æœ¬ æ”¯æŒäºŒè¿›åˆ¶     r.Form r.ParseForm() Y Y Y    r.PostForm r.ParseForm()  Y Y    r.FormValue() è‡ªåŠ¨è°ƒç”¨r.ParseForm() Y Y Y    r.PostFormValue() è‡ªåŠ¨è°ƒç”¨r.ParseForm()  Y Y    r.MultipartForm ParseMultipartForm()  Y Y Y   r.FormFile è‡ªåŠ¨è°ƒç”¨ParseMultipartForm()  Y  Y    Handler , Handle , HandleFunc ä¸ http.ListenAndServe ä½¿ç”¨é»˜è®¤çš„Handler å…ˆçœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­\npackage main  import \u0026#34;net/http\u0026#34;  func main() { \thttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello, world!\u0026#34;)) \t}) \thttp.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) \t})  \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, nil) } åœ¨å¯åŠ¨ä¸€ä¸ªHttpServerçš„æ—¶å€™, å…¶å®æˆ‘ä»¬å°±å…³å¿ƒ2ä¸ªä¸œè¥¿:\n åœ°å€ è·¯ç”±: å°†è¯·æ±‚å¯¹åº”åˆ°ç›¸åº”çš„å¤„ç†å‡½æ•°ä¸­å»  è¿™ä¸¤ä¸ªå‚æ•° åœ¨http.ListenAndServe(\u0026quot;:12345\u0026quot;, nil)ä¸­è¿›è¡Œè®¾ç½®çš„, ç¬¬ä¸€ä¸ªä¸ºåœ°å€, ç¬¬äºŒä¸ªä¼ é€’å¤„ç†å‡½æ•°.\nå¦‚æœä¼ é€’nil, åˆ™é‡‡ç”¨é»˜è®¤çš„\n The handler is typically nil, in which case the DefaultServeMux is used.\n http.ListenAndServeçš„å®ç°å¦‚ä¸‹:\nfunc ListenAndServe(addr string, handler Handler) error { \tserver := \u0026amp;Server{Addr: addr, Handler: handler} \treturn server.ListenAndServe() } type Handler interface {  ServeHTTP(ResponseWriter, *Request) } å¯ä»¥çœ‹åˆ° Handleræ˜¯ä¸€ä¸ªæ¥å£, å®ç°è¿™ä¸ªæ¥å£çš„è¯, æˆ‘ä»¬å¯ä»¥åˆ›å»ºè‡ªå·±çš„Handler\nè‡ªå®šä¹‰Handler å®šä¹‰ä¸€ä¸ªç»“æ„ä½“, ç»“æ„ä½“å®ç° ServeHTTP(w http.ResponseWriter, r *http.Request)æ–¹æ³•\nç„¶åä½¿ç”¨ Handleå‡½æ•°è¿›è¡Œè·¯ç”±æ³¨å†Œ\npackage main  import \u0026#34;net/http\u0026#34;  type MyIndexHandler struct { }  func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;Hello World\u0026#34;)) }  type MyBlogHandler struct { }  func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { \tw.Write([]byte(\u0026#34;This is my Blog\u0026#34;)) }  func main() { \tmux := http.NewServeMux() \tmux.Handle(\u0026#34;/\u0026#34;, \u0026amp;MyIndexHandler{}) \tmux.Handle(\u0026#34;/blog\u0026#34;, \u0026amp;MyBlogHandler{}) \thttp.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } OSX MP16 ~ â¯ curl localhost:12345 Hello World OSX MP16 ~ â¯ curl localhost:12345/blog This is my Blog OSX MP16 ~ â¯ ä½†è¿™æ˜æ˜¾çœ‹å‡ºæ¥, å¯¹æ¯ä¸€ä¸ªè·¯ç”± éƒ½è¦é«˜å†™ä¸€ä¸ªxxxHandlerç»“æ„ä½“å’Œå®ç°ServeHTTP, çœ‹ä¸Šå»éå¸¸æ··ä¹±\nè¿™æ—¶å€™å°±å¯ä»¥ç”¨mux.HandleFuncæ¥å®ç°è·¯ç”±\npackage main  import \u0026#34;net/http\u0026#34;  func main() {  mux := http.NewServeMux()  mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;Hello World\u0026#34;))  })  mux.HandleFunc(\u0026#34;/blog\u0026#34;, func(w http.ResponseWriter, r *http.Request) {  w.Write([]byte(\u0026#34;This is my Blog\u0026#34;))  })   http.ListenAndServe(\u0026#34;:12345\u0026#34;, mux) } è‡ªå®šä¹‰ServeMux åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­, mux := http.NewServeMux()è¿˜æ˜¯ä½¿ç”¨äº†é»˜è®¤router, å…¶ç®€å•çš„åŒæ—¶ä¹Ÿæœ‰ä¸å°‘ç¼ºç‚¹\næ¯”å¦‚, å…¶æ˜¯é€šè¿‡urlè¿›è¡Œè·¯ç”±, ä½†ä¸æ”¯æŒåŸºäºæ–¹æ³•(GET, POST\u0026hellip;)çš„è·¯ç”±, ä¸æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ç­‰ç­‰\nå‚è€ƒè¿™ä¸ª https://www.alexedwards.net/blog/which-go-router-should-i-use\näººæ°”Webæ¡†æ¶ å‚è€ƒè¿™ç¯‡æ–‡ç« ,\nhttps://blog.51cto.com/coderaction/3001008\nå…¶ä¸­æœ‰å„æ¡†æ¶çš„å¯¹æ¯”, åŠŸèƒ½ä¸Širisæœ€å…¨\nhttps://github.com/kataras/iris\n","permalink":"/posts/golang_http_server/","summary":"ç®€å•çš„æ–‡ä»¶æœåŠ¡å™¨ package main  import ( \t\u0026#34;log\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \terr := http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) \tif err != nil { \tlog.Fatal(err) \t} } ä¸Šé¢è¿™ä¸ªä¾‹å­åˆ›å»ºäº†ä¸€ä¸ªä»¥å½“å‰ç›®å½•ä¸ºç«™ç‚¹è·Ÿç›®å½•çš„æ–‡ä»¶æœåŠ¡å™¨, æˆ‘ä¸€èˆ¬ç”¨è¿™ä¸ªæ¥ä½œä¸ºå±€åŸŸç½‘æ–‡ä»¶å…±äº«.\nç„¶åå†™ä¸€ä¸ªå‡½æ•°æ”¾åˆ°bash.rc æˆ–zshrcä¸­\n#æ–‡ä»¶æœåŠ¡å™¨ function fileserver(){ \techo \u0026#34;start file server :12345\u0026#34; \tcat \u0026lt;\u0026lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { err := http.ListenAndServe(\u0026#34;:12345\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;))) if err !","title":"[Golang]Http Server"},{"content":"æˆ‘ä»¬å°†ç”¨äº›ç®€å•çš„ä¾‹å­æ¥å°è¯•golangä¸­syncåŒ…çš„å„ç§æœ‰è¶£çš„æƒ…å†µ\nä¸€ä¸ªç®€å•çš„DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } ç¨‹åºå¾ˆç®€å•, æˆ‘ä»¬ç”¨ä¸€ä¸ªå…±äº«å˜é‡sharedCounterä½œä¸ºä¸€ä¸ªè®¡æ•°å™¨. addå‡½æ•°åœ¨è®¡æ•°å™¨ä¸Šå¾ªç¯æ·»åŠ ä¸€å®šçš„æ•°å€¼, subåˆ™ç›¸å, showåˆ™æ˜¯æ‰“å°è®¡æ•°å™¨å½“å‰çš„å€¼.\nç¨‹åºè¿è¡Œç»“æŸå, sharedCounteråº”è¯¥ä¸º0, ä¸Šé¢ä»£ç çš„è¾“å‡ºçš„ç¡®å¦‚æ­¤.\nä½¿ç”¨ä¸€ä¸ªåç¨‹ å¦‚æœå¯¹è®¡æ•°å™¨è¿›è¡ŒåŠ å‡çš„è°ƒç”¨åœ¨ä¸åŒçš„åç¨‹é‡Œé¢, ä¼šæ€ä¹ˆæ ·å‘¢?\nfunc main() { \tadd(1000000) \tgo sub(1000000) \tshow() } ä¼šå¾—åˆ°1000000 , å› ä¸ºgo sub(1000000)åˆšå¯åŠ¨, ç¨‹åºå°±é€€å‡ºäº†.\næˆ–è®¸æˆ‘ä»¬åº”è¯¥ç­‰åˆ°subå‡½æ•°æ‰§è¡Œç»“æŸ\nç­‰å¾…åç¨‹ç»“æŸ   é”™è¯¯çš„æ–¹å¼ å¦‚æœæœ‰Cè¯­è¨€å¼€å‘èƒŒæ™¯, å¯èƒ½ä¼šæƒ³åˆ°é€šè¿‡è®¾ç½®ä¸€ä¸ªflagæ¥æŒ‡ç¤ºè¿ç®—æ˜¯å¦ç»“æŸ, æ¯”å¦‚:\nfunc sub(count int, done *bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \t*done = true } //....  func main() { \tadd(1000000)  \tdone := false \tgo sub(1000000, \u0026amp;done)  \tfor !done { \ttime.Sleep(time.Millisecond * 10) \t}  \tshow() } è¿™è™½ç„¶ä¹Ÿèƒ½å¾—åˆ°æ­£ç¡®çš„è¾“å‡º, ä½†éå¸¸ä¸ä¼˜é›….\n  æ­£ç¡®çš„æ–¹å¼1 å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ— ç¼“å†²çš„ä¿¡é“(æˆ–è€…è¯´å®¹é‡ä¸º1çš„ä¿¡é“)æ¥å……å½“flag\n//... func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tdone \u0026lt;- true } //.... func main() { \tadd(1000000)  \tdone := make(chan bool) \tgo sub(1000000, done) \t\u0026lt;-subDone \tshow() } è¿™é‡Œåˆ©ç”¨äº†ä¿¡é“çš„ç‰¹ç‚¹: å½“ä»ä¿¡é“ä¸­è¯»å–æ•°æ®æ—¶,å¦‚æœä¿¡é“ä¸ºç©º,è¯»å–å°†è¢«é˜»å¡ç›´åˆ°æœ‰æ•°æ®åˆ°è¾¾. æ‰€ä»¥ \u0026lt;-subDone ä¼šä¸€ç›´é˜»å¡, ç›´åˆ°é€šè¿‡subDone \u0026lt;- trueå‘å…¶ä¸­å†™å…¥äº†æ•°æ®\n  ä½¿ç”¨2ä¸ªåç¨‹ ä¸Šé¢çš„ä¾‹å­ä¸­, sub(1000000, done)æ˜¯åœ¨æ–°çš„åç¨‹ä¸­è¿è¡Œçš„, add(1000000)å´ä¸æ˜¯, å¦‚æœä»–ä»¬éƒ½åœ¨æ–°åç¨‹ä¸­è¿è¡Œ, ä¸»ç¨‹åºåº”è¯¥å¦‚ä½•ç­‰å¾…ä»–ä»¬ç»“æŸå‘¢\nå¾ˆå®¹æ˜“æƒ³åˆ°, ä½¿ç”¨ä¸¤æ¬¡\u0026lt;-done ä¹Ÿå°±æ˜¯è¯´å‘ä¿¡é“ç´¢è¦ä¸¤ä¸ªè®¡ç®—å®Œæˆçš„æ ‡å¿—, addå’Œ sub è®¡ç®—å®Œæˆååˆ†åˆ«å‘å…¶ä¸­æ”¾å…¥æ ‡å¿—.\npackage main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } ä¸ºäº†æ˜ç¡®çŸ¥é“mainå‡½æ•°çš„ç¡®æ˜¯ç­‰å¾…ä¸¤ä¸ªåç¨‹æ‰§è¡Œå®Œæ¯•äº†çš„, æˆ‘ä»¬åœ¨å…¶ä¸­åŠ å…¥äº†fmt.Println(\u0026quot;sub done\u0026quot;)è¿™æ ·çš„è¾“å‡º\nè¿è¡Œç¨‹åº, å¾—åˆ°\nadd done sub done 824933 Opps, è™½ç„¶addå’Œsub éƒ½æ‰§è¡Œå®Œæ¯•äº†,ä½†æ˜¯ç»“æœä¸å¯¹(å¹¶ä¸”å¤šæ¬¡è¿è¡Œçš„ç»“æœè¿˜ä¸ç›¸åŒ), æœŸæœ›æ¥æ”¶åº”è¯¥æ˜¯0\nå†è¿è¡Œä¸€æ¬¡, å¾—åˆ°:\nsub done add done -481342 åŸå› æ˜¯addå’Œsubåœ¨äº¤å‰è¯»å–å’Œå†™å…¥sharedCounterè¿™ä¸ªå˜é‡, ä»–ä»¬å…±äº«äº†å˜é‡, ä½†åœ¨è¯»å–å’Œå†™å…¥çš„æ—¶å€™å‡ºç°**\u0026ldquo;ç«æ€\u0026rdquo;**\nç«æ€ æœ‰å¤šä¸ªåç¨‹è¿è¡Œæ—¶, å¯¹äºæ¯ä¸ªåç¨‹è€Œè¨€,å…¶å†…éƒ¨ä»£ç æ—¶é¡ºåºæ‰§è¡Œçš„, ä½†æ— æ³•ç¡®å®šåç¨‹ä¹‹é—´çš„æ‰§è¡Œé¡ºåº, é‚£ä¹ˆå°±è¯´è¿™äº›åç¨‹æ˜¯å¹¶å‘çš„\nå¦‚æœä¸€æ®µä»£ç æ— è®ºæ˜¯é¡ºåºæ‰§è¡Œè¿˜æ˜¯å¹¶å‘æ‰§è¡Œ,å…¶ç»“æœéƒ½æ˜¯ç¡®å®šçš„,é‚£ä¹ˆè¿™ä¸ªä»£ç å°±æ˜¯å¹¶å‘å®‰å…¨çš„.\nç›¸å, å¹¶å‘ä¸å®‰å…¨çš„ä»£ç ,å¯èƒ½ä¼šå‡ºç°æ­»é”,æ´»é”,ç«æ€\nç«æ€åˆ™è¡¨ç¤ºä»£ç å¯æ‰§è¡Œ,ä½†å¯èƒ½å‡ºç°ç»“æœä¸ä¸€è‡´(é”™è¯¯ç»“æœ)\n###è§£å†³æ–¹æ³•1, åˆ©ç”¨ä¿¡é“\nfunc main() { \tdone := make(chan bool) \tgo add(1000000, done) \t\u0026lt;-done //1 \tgo sub(1000000, done) \t\u0026lt;-done //2 \tshow() } åœ¨addæ‰§è¡Œå®Œæ¯•ä¹‹å‰, é¦–å…ˆä¼šå µå¡åœ¨//1å¤„,\nfunc add(count int, done chan bool) { \t//.... \tdone \u0026lt;- true } addå‡½æ•°æ‰§è¡Œæœ€åä¸€å¥ done \u0026lt;- true å \u0026lt;-done //1èƒ½å–åˆ°å€¼, æ¥è§¦é˜»å¡. ç„¶åç»§ç»­å¾€ä¸‹æ‰§è¡Œsubå‡½æ•°.\nè¿™è™½ç„¶èƒ½å¾—åˆ°æ­£ç¡®è¾“å‡º, ä½†, æˆ‘ä»¬å‘ç°, è¿™å®é™…æ˜¯å°†å¹¶è¡Œæ‰§è¡Œä¿®æ”¹æˆäº†ä¸²è¡Œæ‰§è¡Œ.\nè§£å†³æ–¹æ³•2, åˆ©ç”¨ Mutex æˆ– RWMutex sync.Mutex å¯èƒ½æ˜¯åŒæ­¥åŒ…ä¸­ä½¿ç”¨æœ€å¹¿æ³›çš„åŸè¯­ã€‚å®ƒå…è®¸å¯¹å…±äº«èµ„æºè¿›è¡Œäº’æ–¥ï¼ˆä¸èƒ½åŒæ—¶è®¿é—®).\nmutex := \u0026amp;sync.Mutex{}  mutex.Lock() //.... æ›´æ–°å…±äº«å˜é‡ mutex.Unlock() æ³¨æ„: åœ¨å®˜æ–¹æ–‡æ¡£ä¸­æœ‰è¿™ä¹ˆä¸€å¥ \u0026ldquo;Values containing the types defined in this package should not be copied.\u0026rdquo; (\u0026ldquo;åŒ…å«è¿™ä¸ªåŒ…ä¸­å®šä¹‰çš„ç±»å‹çš„å€¼ä¸åº”è¯¥è¢«å¤åˆ¶ã€‚\u0026rdquo;) . æˆ‘ä»¬ç›´åˆ°å€¼ä¼ é€’å°±æ˜¯å¤åˆ¶ç„¶åä¼ é€’, æ‰€ä»¥æˆ‘ä»¬ä»£ç ä¸­çš„mutexç”¨çš„æ˜¯å¼•ç”¨ä¼ é€’.\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; )  var ( \tsharedCounter = 0 \tmutex = \u0026amp;sync.Mutex{} )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter++ \tmutex.Unlock() \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tsharedCounter-- \tmutex.Unlock() \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } åœ¨è¯»å†™sharedCounterä¹‹å‰å…ˆLock(), ç”¨å®ŒåUnlock()\nå¦‚æœæˆ‘ä»¬åœ¨è¿›è¡Œè®¡ç®—çš„æ—¶å€™åŠ ä¸Šç‚¹æ‰“å°(ä»…æµ‹è¯•ç”¨,éå¸¸å½±å“é€Ÿåº¦)\nfor i := 0; i \u0026lt; count; i++ { \tmutex.Lock() \tfmt.Println(\u0026#34;--\u0026#34;) // fmt.Println(\u0026#34;++\u0026#34;) \tsharedCounter-- // sharedCounter++ \tmutex.Unlock() \t} åˆ™å¯ä»¥çœ‹åˆ° ++ å’Œ \u0026ndash; æ˜¯äº¤å‰ç€æ‰“å°çš„, è¯´æ˜æ˜¯å¹¶è¡Œæ‰§è¡Œçš„.\nå¦å¤–, è¿˜æœ‰RWMutex (è¯»å†™é”), é™¤äº†ä¸Mutexç›¸åŒçš„Lock()å’ŒUnlock()æ–¹æ³•å¤–, å…¶è¿˜æœ‰ç”¨äºå…±äº«è¯»æ“ä½œçš„RLock()å’ŒRUnlock(), åœ¨è¯»å–å…±äº«å˜é‡æ—¶å…è®¸åŒæ—¶å¤šä¸ªè¯»å–å™¨èƒ½æé«˜æ•ˆç‡. æ‰€ä»¥åœ¨é¢‘ç¹è¯»å†™æ“ä½œçš„ä»£ç ä¸­, ä½¿ç”¨RWMutexæ•ˆç‡è¦æ¯”Mutexé«˜\nè§£å†³æ–¹æ³•3, åˆ©ç”¨åŸå­æ“ä½œ åŸå­æ“ä½œåœ¨\u0026quot;sync/atomic\u0026quot;åŒ…ä¸­. åˆ©ç”¨è¿™ä¸ªåŒ…ä¸­æä¾›çš„å‡½æ•°å¯å®ç°\u0026quot;æ— é”ç‰ˆ\u0026quot;çš„å…±äº«å˜é‡è¯»å†™\nåŸå­æ“ä½œå³æ˜¯è¿›è¡Œè¿‡ç¨‹ä¸­ä¸èƒ½è¢«ä¸­æ–­çš„æ“ä½œï¼Œé’ˆå¯¹æŸä¸ªå€¼çš„åŸå­æ“ä½œåœ¨è¢«è¿›è¡Œçš„è¿‡ç¨‹ä¸­ï¼ŒCPUç»ä¸ä¼šå†å»è¿›è¡Œå…¶ä»–çš„é’ˆå¯¹è¯¥å€¼çš„æ“ä½œã€‚ä¸ºäº†å®ç°è¿™æ ·çš„ä¸¥è°¨æ€§ï¼ŒåŸå­æ“ä½œä»…ä¼šç”±ä¸€ä¸ªç‹¬ç«‹çš„CPUæŒ‡ä»¤ä»£è¡¨å’Œå®Œæˆã€‚åŸå­æ“ä½œæ˜¯æ— é”çš„ï¼Œå¸¸å¸¸ç›´æ¥é€šè¿‡CPUæŒ‡ä»¤ç›´æ¥å®ç°ã€‚ äº‹å®ä¸Šï¼Œå…¶å®ƒåŒæ­¥æŠ€æœ¯çš„å®ç°å¸¸å¸¸ä¾èµ–äºåŸå­æ“ä½œ\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync/atomic\u0026#34; )  var ( \tsharedCounter = int64(0) )  func add(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, 1) // \t}  \tfmt.Println(\u0026#34;add done\u0026#34;) \tdone \u0026lt;- true }  func sub(count int, done chan bool) { \tfor i := 0; i \u0026lt; count; i++ { \tatomic.AddInt64(\u0026amp;sharedCounter, -1) // \t} \tfmt.Println(\u0026#34;sub done\u0026#34;) \tdone \u0026lt;- true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \t\u0026lt;-done \t\u0026lt;-done \tshow() } åŸå­æ“ä½œçš„å¸¸ç”¨æ¥å£å¦‚ä¸‹(ä»¥int32ä¸ºä¾‹)\n//å°†addræŒ‡å‘çš„å€¼å’Œoldè¿›è¡Œæ¯”è¾ƒ, å¦‚æœç›¸ç­‰,åˆ™å°†newèµ‹å€¼åˆ°addræŒ‡å‘çš„ä½ç½®,å¹¶è¿”å›true, å¦‚æœä¸ç›¸ç­‰,åˆ™ç›´æ¥è¿”å›false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)   //ä½¿ç”¨åŸå­æ“ä½œ,å°†addræŒ‡å‘çš„ä½ç½®å¢åŠ ä¸€ä¸ªdelta func AddInt32(addr *int32, delta int32) (new int32)  //åŸå­è¯»å– //å½“æˆ‘ä»¬è¦è¯»å–ä¸€ä¸ªå˜é‡çš„æ—¶å€™ï¼Œå¾ˆæœ‰å¯èƒ½è¿™ä¸ªå˜é‡æ­£åœ¨è¢«å†™å…¥ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å°±å¾ˆæœ‰å¯èƒ½è¯»å–åˆ°å†™åˆ°ä¸€åŠçš„æ•°æ®ã€‚ æ‰€ä»¥è¯»å–æ“ä½œæ˜¯éœ€è¦ä¸€ä¸ªåŸå­è¡Œä¸ºçš„ã€‚ func LoadInt32(addr *int32) (val int32)  //è¯»å–æ˜¯æœ‰åŸå­æ€§çš„æ“ä½œçš„ï¼ŒåŒæ ·å†™å…¥atomicåŒ…ä¹Ÿæä¾›äº†ç›¸å…³çš„æ“ä½œåŒ… func StoreInt32(addr *int32, val int32)   //æ­¤ç±»å‹çš„å€¼ç›¸å½“äºä¸€ä¸ªå®¹å™¨ï¼Œå¯ä»¥è¢«ç”¨æ¥â€œåŸå­åœ°\u0026#34;å­˜å‚¨ï¼ˆStoreï¼‰å’ŒåŠ è½½ï¼ˆLoadï¼‰ä»»æ„ç±»å‹çš„å€¼ã€‚å½“ç„¶è¿™ä¸ªç±»å‹ä¹Ÿæ˜¯åŸå­æ€§çš„ã€‚ //æœ‰äº†atomic.Valueè¿™ä¸ªç±»å‹ï¼Œè¿™æ ·ç”¨æˆ·å°±å¯ä»¥åœ¨ä¸ä¾èµ–Goå†…éƒ¨ç±»å‹unsafe.Pointerçš„æƒ…å†µä¸‹ä½¿ç”¨åˆ°atomicæä¾›çš„åŸå­æ“ä½œã€‚ // A Value must not be copied after first use. type Value struct { \tv interface{} }  åŸå­æ“ä½œä¸äº’æ–¥é”çš„åŒºåˆ«\né¦–å…ˆatomicæ“ä½œçš„ä¼˜åŠ¿æ˜¯æ›´è½»é‡ï¼Œæ¯”å¦‚CASå¯ä»¥åœ¨ä¸å½¢æˆä¸´ç•ŒåŒºå’Œåˆ›å»ºäº’æ–¥é‡çš„æƒ…å†µä¸‹å®Œæˆå¹¶å‘å®‰å…¨çš„å€¼æ›¿æ¢æ“ä½œã€‚è¿™å¯ä»¥å¤§å¤§çš„å‡å°‘åŒæ­¥å¯¹ç¨‹åºæ€§èƒ½çš„æŸè€—ã€‚\nåŸå­æ“ä½œä¹Ÿæœ‰åŠ£åŠ¿ã€‚è¿˜æ˜¯ä»¥CASæ“ä½œä¸ºä¾‹ï¼Œä½¿ç”¨CASæ“ä½œçš„åšæ³•è¶‹äºä¹è§‚ï¼Œæ€»æ˜¯å‡è®¾è¢«æ“ä½œå€¼æœªæ›¾è¢«æ”¹å˜ï¼ˆå³ä¸æ—§å€¼ç›¸ç­‰ï¼‰ï¼Œå¹¶ä¸€æ—¦ç¡®è®¤è¿™ä¸ªå‡è®¾çš„çœŸå®æ€§å°±ç«‹å³è¿›è¡Œå€¼æ›¿æ¢ï¼Œé‚£ä¹ˆåœ¨è¢«æ“ä½œå€¼è¢«é¢‘ç¹å˜æ›´çš„æƒ…å†µä¸‹ï¼ŒCASæ“ä½œå¹¶ä¸é‚£ä¹ˆå®¹æ˜“æˆåŠŸã€‚è€Œä½¿ç”¨äº’æ–¥é”çš„åšæ³•åˆ™è¶‹äºæ‚²è§‚ï¼Œæˆ‘ä»¬æ€»å‡è®¾ä¼šæœ‰å¹¶å‘çš„æ“ä½œè¦ä¿®æ”¹è¢«æ“ä½œçš„å€¼ï¼Œå¹¶ä½¿ç”¨é”å°†ç›¸å…³æ“ä½œæ”¾å…¥ä¸´ç•ŒåŒºä¸­åŠ ä»¥ä¿æŠ¤ã€‚\nä¸‹é¢æ˜¯å‡ ç‚¹åŒºåˆ«ï¼š\n äº’æ–¥é”æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”¨æ¥è®©ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç¨‹åºçš„å…³é”®éƒ¨åˆ†ï¼Œå®Œæˆäº’æ–¥çš„å¤šä¸ªæ“ä½œ åŸå­æ“ä½œæ˜¯æ— é”çš„ï¼Œå¸¸å¸¸ç›´æ¥é€šè¿‡CPUæŒ‡ä»¤ç›´æ¥å®ç° åŸå­æ“ä½œä¸­çš„casè¶‹äºä¹è§‚é”ï¼ŒCASæ“ä½œå¹¶ä¸é‚£ä¹ˆå®¹æ˜“æˆåŠŸï¼Œéœ€è¦åˆ¤æ–­ï¼Œç„¶åå°è¯•å¤„ç† å¯ä»¥æŠŠäº’æ–¥é”ç†è§£ä¸ºæ‚²è§‚é”ï¼Œå…±äº«èµ„æºæ¯æ¬¡åªç»™ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œå…¶å®ƒçº¿ç¨‹é˜»å¡ï¼Œç”¨å®Œåå†æŠŠèµ„æºè½¬è®©ç»™å…¶å®ƒçº¿ç¨‹    ä¸è¦è½»æ˜“ä½¿ç”¨atomic\nhttps://texlution.com/post/golang-lock-free-values-with-atomic-value/\n å…¶å®ƒå¹¶å‘æ§åˆ¶æ–¹æ³• ä¸Šé¢çš„ä¾‹å­ä¸­, æˆ‘ä»¬éƒ½æ˜¯ä½¿ç”¨çš„ä¿¡é“æ¥è¿›è¡Œå¹¶å‘æ§åˆ¶ (done \u0026lt;- trueä¸\u0026lt;-done), è¿™åªæ˜¯å¸¸ç”¨çš„æ–¹æ³•ä¹‹ä¸€\nWaitGroup sync.WaitGroup æ‹¥æœ‰ä¸€ä¸ªå†…éƒ¨è®¡æ•°å™¨ã€‚å¦‚æœæ­¤è®¡æ•°å™¨ç­‰äº 0ï¼Œåˆ™ Wait() æ–¹æ³•ç«‹å³è¿”å›ã€‚å¦åˆ™ï¼Œå®ƒå°†è¢«é˜»å¡ï¼Œç›´åˆ°è®¡æ•°å™¨ä¸º 0ã€‚\nè¦å¢åŠ è®¡æ•°å™¨ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ Add(int)ã€‚è¦å‡å°‘å®ƒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Done() ï¼ˆå°†å‡å°‘ 1ï¼‰æˆ–å…·æœ‰è´Ÿå€¼çš„ç›¸åŒ Add(int) æ–¹æ³•ã€‚\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;sync\u0026#34;  \u0026#34;sync/atomic\u0026#34; )  var (  sharedCounter = int64(0) )  func add(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, 1)  }   fmt.Println(\u0026#34;add done\u0026#34;)  wg.Done() }  func sub(count int, wg *sync.WaitGroup) {  for i := 0; i \u0026lt; count; i++ {  atomic.AddInt64(\u0026amp;sharedCounter, -1)  }  fmt.Println(\u0026#34;sub done\u0026#34;)  wg.Done() }  func show() {  fmt.Println(sharedCounter) }  func main() {  wg := sync.WaitGroup{}  wg.Add(2)   go add(1000000, \u0026amp;wg)  go sub(1000000, \u0026amp;wg)   wg.Wait()  show() } æ³¨æ„:ä¼ é€’ WaitGroupæ—¶è¦ä½¿ç”¨å¼•ç”¨ä¼ é€’(æŒ‡é’ˆ), å…¶ä¸åº”è¯¥è¢«å¤åˆ¶. func sub(count int, wg *sync.WaitGroup)\ncontext.Context Contextæä¾›äº†2ä¸ªåŠŸèƒ½\n æ§åˆ¶å­åç¨‹ç»“æŸ ä¼ é€’å€¼  å…¶ä¸åœ¨syncåŒ…ä¸­, åé¢ä¸“é—¨è®²\nsync.Pool å¯¹è±¡å¤ç”¨ å…¶æä¾›ä¸€ä¸ª\u0026quot;å¹¶å‘å®‰å…¨\u0026quot;çš„å¯å¤ç”¨çš„å¯¹è±¡æ± . ç”¨æ¥å‡å°‘é¢‘ç¹GCæ‰€ä»£ç†çš„å‹åŠ›.\nå…¶å¤§æ¦‚æ„æ€æ˜¯: å¦‚æœæœ‰æ—§å¯¹è±¡å¯ç”¨,åˆ™ç”¨æ—§çš„, æ²¡æœ‰å†Newä¸€ä¸ª\nå‚è€ƒè¿™æ‰¹æ–‡ç« : https://www.cnblogs.com/qcrao-2018/p/12736031.html\nä»¥åŠè¿™é‡Œ https://geektutu.com/post/hpg-sync-pool.html\nåœ¨å®é™…å¼€å‘å·¥ä½œä¸­, ä¸è¦ä¸€ä¸Šæ¥å°±æƒ³åšä½¿ç”¨sync.Poolå®ƒé€šå¸¸ä¼šå¸¦æ¥é—®é¢˜(å› ä¸ºå…¶Getå‡ºæ¥çš„å¯¹è±¡çš„çŠ¶æ€æ˜¯ä¸ç¡®å®šçš„), è€Œåº”è¯¥éµå¾ªä¸‹é¢çš„åŸåˆ™:\n æ ¹æ®ä½ æ”¶é›†åˆ°çš„éœ€æ±‚è®¾è®¡ä½ çš„ä»£ç ï¼ˆä¸è¦è·³è¿‡è¿™ä¸ªæ­¥éª¤ï¼‰ã€‚ ç¼–å†™æœ€ç®€å•ã€æœ€æ¸…æ™°ã€æœ€æ„šè ¢çš„è®¾è®¡å®ç°ã€‚ å¦‚æœå®¢æˆ·æ»¡æ„ï¼Œå°±åœæ­¢ å¦‚æœå®¢æˆ·ä¸æ»¡æ„ï¼Œè€Œä¸”ä»–ä»¬è®¤ä¸ºåº”ç”¨ç¨‹åºçš„æ€§èƒ½ä¸èƒ½æ»¡è¶³ä»–ä»¬çš„è¦æ±‚ï¼Œé‚£ä¹ˆå°±å‰–æã€‚ è§£å†³æœ€é«˜æ€§èƒ½çš„ä¸»å¯¼è€… å‰–æå¹¶è¿›å…¥ç¬¬äº”é˜¶æ®µã€‚ç„¶åè¿›å…¥3 å¦‚æœå®åœ¨æä¸å®š, å†æƒ³æƒ³sync.Pool  sync.Once åªæ‰§è¡Œä¸€æ¬¡ sync.Once æä¾›äº†ä¸€ç§æ–¹æ³•, è®©ç›¸å…³ä»£ç åªè¢«æ‰§è¡Œä¸€æ¬¡\nå®é™…å¼€å‘è¿‡ç¨‹ä¸­, ç»å¸¸æœ‰è¿™æ ·çš„åœºæ™¯: ä½ åšäº†ä¸€ä¸ªå«åšlowLevelApiçš„åŒ…, ç”¨äºæ§åˆ¶åº•å±‚è®¾å¤‡, æ¯”å¦‚å¼€å…³LED, ä½†åœ¨è°ƒç”¨å¼€å…³LEDä¹‹å‰éœ€è¦ç¡®ä¿ä¸€äº›åˆå§‹åŒ–å·¥ä½œå·²ç»å®Œæˆ, æ‰€ä»¥ä½ å†™äº†ä¸€ä¸ªInitEnvçš„å‡½æ•°, å¹¶å‘Šè¯‰å…¶å®ƒå¼€å‘äººå‘˜: ä¸€å®šè¦å…ˆåˆå§‹åŒ–å“¦.\npackage lowLevelApi  import \u0026#34;fmt\u0026#34;  func InitEnv() { \tfmt.Println(\u0026#34;init environment\u0026#34;) }  func LedOn() { \tfmt.Println(\u0026#34;LedOn\u0026#34;) }  func LedOff() { \tfmt.Println(\u0026#34;LedOff\u0026#34;) } å…¶å®ƒå¼€å‘äººå‘˜ç»å¸¸ä¼šé—®ä½ : è¿™ä¸ªåˆå§‹åŒ–å‡½æ•°å¦‚æœè¢«é‡å¤è°ƒç”¨ä¸ä¼šå‡ºé—®é¢˜å§?\nå› ä¸ºä»–ä»¬çš„ä»£ç é€šå¸¸ä¼šè¿™æ ·å†™:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;goplayground/lowLevelApi\u0026#34; )  func turnLedOn() { \tfmt.Println(\u0026#34;Turning LED on\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOn() \tfmt.Println(\u0026#34;LED on\u0026#34;) }  func turnLedOff() { \tfmt.Println(\u0026#34;Turning LED off\u0026#34;) \tlowLevelApi.InitEnv() \tlowLevelApi.LedOff() \tfmt.Println(\u0026#34;LED off\u0026#34;) }  func main() { \tturnLedOn() \tturnLedOff() } ä¸Šé¢çš„ä»£ç ä¼šè¾“å‡º\nTurning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off ä¸ºäº†é˜²æ­¢é‡å¤è°ƒç”¨InitEnv()å¯èƒ½å¸¦æ¥çš„é—®é¢˜, åˆ™å¯ä»¥ä½¿ç”¨sync.Once\nvar ( \tonce sync.Once )  func InitEnv() { \tonce.Do(func() { \tfmt.Println(\u0026#34;InitEnv\u0026#34;) \t}) } è¿™æ ·InitEnv()å³ä½¿è¢«å¤šæ¬¡è°ƒç”¨, å…¶å†…éƒ¨é€»è¾‘åªä¼šæ‰§è¡Œä¸€æ¬¡\nTurning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once å¸¸åº”ç”¨äºå•ä¾‹æ¨¡å¼ï¼Œä¾‹å¦‚åˆå§‹åŒ–é…ç½®ã€ä¿æŒæ•°æ®åº“è¿æ¥ç­‰ã€‚ä½œç”¨ä¸ init å‡½æ•°ç±»ä¼¼ï¼Œä½†æœ‰åŒºåˆ«ã€‚\n init å‡½æ•°æ˜¯å½“æ‰€åœ¨çš„ package é¦–æ¬¡è¢«åŠ è½½æ—¶æ‰§è¡Œï¼Œè‹¥è¿Ÿè¿Ÿæœªè¢«ä½¿ç”¨ï¼Œåˆ™æ—¢æµªè´¹äº†å†…å­˜ï¼Œåˆå»¶é•¿äº†ç¨‹åºåŠ è½½æ—¶é—´ã€‚ sync.Once å¯ä»¥åœ¨ä»£ç çš„ä»»æ„ä½ç½®åˆå§‹åŒ–å’Œè°ƒç”¨ï¼Œå› æ­¤å¯ä»¥å»¶è¿Ÿåˆ°ä½¿ç”¨æ—¶å†æ‰§è¡Œï¼Œå¹¶å‘åœºæ™¯ä¸‹æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚  sync.Cond æ¡ä»¶å˜é‡ sync.Cond ç”¨äºåè°ƒå¤šä¸ªåç¨‹è®¿é—®å…±äº«èµ„æº, å…¶ä¸­æŸäº›åç¨‹å¤„äºé˜»å¡çŠ¶æ€, å¦å¤–ä¸€ä¸ªåç¨‹åœ¨æ¡ä»¶å‡†å¤‡å¥½çš„æ—¶å€™æ¥è®²å…¶å®ƒåç¨‹å”¤é†’.\nä¸‹é¢çš„ä¾‹å­ä¸­ InitEnvå‡½æ•°éœ€è¦ä¸€ç‚¹æ—¶é—´åœ¨å‡†å¤‡sharedCounter çš„åˆå§‹å€¼, åœ¨è¿™æœŸé—´Addå’Œsubå¤„äºWaitçŠ¶æ€, å½“å‡†å¤‡å¥½å, å°†é€šçŸ¥ Addå’ŒSubç»§ç»­å‘ä¸‹æ‰§è¡Œ\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;sync\u0026#34; \t\u0026#34;time\u0026#34; )  var ( \tsharedCounter int )  func InitEnv(c *sync.Cond) { \tfmt.Println(\u0026#34;begin InitEnv\u0026#34;) \ttime.Sleep(time.Second * 1) \tc.L.Lock() \tsharedCounter = 10 \tc.L.Unlock() \tfmt.Println(\u0026#34;Init Env Done, broadcast...\u0026#34;) \tc.Broadcast() }  func Add(cout int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter += cout \tc.L.Unlock() \tfmt.Println(\u0026#34;Add Done\u0026#34;) }  func Sub(count int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter -= count \tc.L.Unlock() \tfmt.Println(\u0026#34;Sub Done\u0026#34;) }  func main() { \tcond := sync.NewCond(\u0026amp;sync.Mutex{}) \tgo InitEnv(cond) \tgo Add(5, cond) \tgo Sub(2, cond)  \ttime.Sleep(2 * time.Second) \tfmt.Println(\u0026#34;Final Counter:\u0026#34;, sharedCounter) } è¾“å‡º\nbegin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()å”¤é†’æ‰€æœ‰ç­‰å¾…çš„åç¨‹, å¦å¤–è¿˜æœ‰ä¸€ä¸ªSignal()æ–¹æ³•, ç”¨äºå”¤é†’ä¸€ä¸ªåç¨‹. sync.Condä¸€èˆ¬ç”¨äºä¸€å¯¹å¤šçš„æƒ…å†µ, å¦‚æœæ˜¯ä¸€å¯¹ä¸€çš„æƒ…å†µ, ç”¨ä¸€ä¸ªä¿¡é“å°±å¯ä»¥è½»æ¾è§£å†³äº†\nsync.Map å†…ç½®çš„mapä¸æ˜¯å¹¶å‘å®‰å…¨çš„, æ‰€ä»¥ sync.Map æä¾›äº†ä¸€ä¸ªåŠŸèƒ½ä¸mapç±»ä¼¼ä½†æ˜¯å¹¶å‘å®‰å…¨çš„ç‰ˆæœ¬\nå¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç«  https://juejin.cn/post/6844903895227957262\n","permalink":"/posts/go_talk_about_sync/","summary":"æˆ‘ä»¬å°†ç”¨äº›ç®€å•çš„ä¾‹å­æ¥å°è¯•golangä¸­syncåŒ…çš„å„ç§æœ‰è¶£çš„æƒ…å†µ\nä¸€ä¸ªç®€å•çš„DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } ç¨‹åºå¾ˆç®€å•, æˆ‘ä»¬ç”¨ä¸€ä¸ªå…±äº«å˜é‡sharedCounterä½œä¸ºä¸€ä¸ªè®¡æ•°å™¨.","title":"[Golang]èŠèŠsync"},{"content":"å‰ä¸¤å¤©åœ¨ä¸€ä¸ªé¡¹ç›®ä¸­éœ€è¦å®ç°è¿™æ ·ä¸€ä¸ªåŠŸèƒ½\u0026quot;ç‚¹å‡»ä¸€ä¸ªæŒ‰é’®æˆ–é€šè¿‡APIæ¥é‡å¯åå°æœåŠ¡\u0026quot;\nå‘ç°Githubä¸Šæœ‰ä¸€ä¸ªå«overseerçš„æ¨¡å—, è¯•ç”¨äº†ä¸€ä¸‹,æ•ˆæœè¿˜ä¸é”™\nä½¿ç”¨æ–¹æ³•å¾ˆç®€å•\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, å›è½¦é”®é‡å¯APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } é¡¹ç›®åœ°å€: https://github.com/jpillora/overseer\nå…¶READMEä¸­ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨è¿™ä¸ªæ¨¡å—æ¥ä¼˜é›…åœ°è¿›è¡Œè‡ªæˆ‘å‡çº§.\n","permalink":"/posts/golang_overseer_restart_app/","summary":"å‰ä¸¤å¤©åœ¨ä¸€ä¸ªé¡¹ç›®ä¸­éœ€è¦å®ç°è¿™æ ·ä¸€ä¸ªåŠŸèƒ½\u0026quot;ç‚¹å‡»ä¸€ä¸ªæŒ‰é’®æˆ–é€šè¿‡APIæ¥é‡å¯åå°æœåŠ¡\u0026quot;\nå‘ç°Githubä¸Šæœ‰ä¸€ä¸ªå«overseerçš„æ¨¡å—, è¯•ç”¨äº†ä¸€ä¸‹,æ•ˆæœè¿˜ä¸é”™\nä½¿ç”¨æ–¹æ³•å¾ˆç®€å•\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;github.com/jpillora/overseer\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \toverseer.Run(overseer.Config{ \tProgram: app, \t}) }  func app(overseer.State) {  \tfmt.Println(\u0026#34;app started : \u0026#34; + time.Now().Format(\u0026#34;2006-01-02 03:04:05 pm\u0026#34;))  \tfmt.Println(\u0026#34;Hello, å›è½¦é”®é‡å¯APP\u0026#34;)  \t_, _ = fmt.Scanln()  \toverseer.Restart() } é¡¹ç›®åœ°å€: https://github.com/jpillora/overseer\nå…¶READMEä¸­ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨è¿™ä¸ªæ¨¡å—æ¥ä¼˜é›…åœ°è¿›è¡Œè‡ªæˆ‘å‡çº§.","title":"[Golang] ä½¿ç”¨overseerå®ç°APPé‡å¯"},{"content":"ç¬¬1æ­¥ï¼šåœ¨Githubä¸Šæ–°å»ºä¸€ä¸ªé¡¹ç›® ç™»å½•ä½ çš„Githubè´¦å·ï¼ŒæŒ‰ç…§å‘å¯¼ æ–°å»ºä¸€ä¸ª Repository\nå‡è®¾ä½ æ–°å»ºçš„Repoä¸ºï¼š https://github.com/yourUserName/MyBlog.git\nç¬¬2æ­¥ï¼š Cloneé¡¹ç›®åˆ°æœ¬åœ°å¹¶å°è¯•push git clone https://github.com/yourUserName/MyBlog.git å°è¯•æ–°å»ºä¸€ä¸ªæ–‡ä»¶å’Œpush\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main å°è¯•æäº¤çš„æ—¶å€™ï¼Œä¼šè®©ä½ è¾“å…¥githubè´¦å·å’Œtokenï¼ˆgitbubå¼ƒç”¨äº†å¯†ç ç™»å½•ï¼Œè€Œæ˜¯ä½¿ç”¨tokenï¼‰\nå¦‚æœä½ è¿˜æ²¡æœ‰ç”Ÿæˆè¿‡tokenï¼Œå¯ä»¥åˆ°Githubä½ è´¦æˆ·ä¸‹çš„settings -\u0026gt; Developer settings ä¸‹ç”Ÿæˆtoken\nç¬¬3æ­¥ï¼šä½¿ç”¨hugoè‡ªåŠ¨ç”Ÿæˆé™æ€ç½‘ç«™  å®‰è£…hugo  brew install hugo   æŒ‰ç…§å®˜æ–¹æ•™ç¨‹æ–°å»ºä¸€ä¸ªç½‘ç«™ å®˜æ–¹æ•™ç¨‹ï¼š https://gohugo.io/getting-started/quick-start/\nå‡è®¾ä½ çš„ç½‘ç«™åç§°å«MySite\n  ç¼–è¯‘ä½ çš„ç½‘ç«™ hugo -D ï¼Œç¼–è¯‘å‡ºæ¥çš„é™æ€ç½‘é¡µçš„å…¨éƒ¨å†…å®¹åœ¨MySite/publicç›®å½•ä¸‹\n  åœ¨æœ¬åœ°è¿è¡Œè¯•è¯• hugo server -D , ä¸å‡ºæ„å¤–ï¼Œä½ åº”è¯¥èƒ½åœ¨http://localhost:1313ä¸Šçœ‹åˆ°ä½ çš„ç«™ç‚¹\n  ç¬¬4æ­¥ï¼šä½¿ç”¨ fleekæ¥å°†å…¶è‡ªåŠ¨éƒ¨ç½²åˆ°IPFSä¸Š   å…³è”Github repoå’Œfleek\næŒ‰ç…§https://docs.ipfs.io/how-to/websites-on-ipfs/introducing-fleek/#host-a-site æ•™ç¨‹ä¸€æ­¥æ­¥åœ°å°†ä½ çš„Githubé¡¹ç›®ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„MyBlog.gitå’Œfleeké¡¹ç›®å…³è”èµ·æ¥ï¼Œè¿™æ ·ï¼Œä½†ä½ çš„gitæœ‰æ›´æ–°åï¼Œfleekä¼šå°†ä½ çš„å†…å®¹è‡ªåŠ¨éƒ¨ç½²åˆ°IPFSä¸Š\nfleekç»™ä½ çš„ä¸´æ—¶å­åŸŸåï¼Œå°±åœ¨é¡¹ç›®çš„ä¸‹æ–¹ï¼Œç±»ä¼¼ xxxxxx.on.fleek.co , ä½ å¯ä»¥è·³è¿‡æ•™ç¨‹ä¸­çš„Domain namesä¸€èŠ‚\n  å°†hugoç¼–è¯‘å‡ºçš„publicä¸‹æ‰€æœ‰å†…å®¹å¤åˆ¶åˆ°æœ¬åœ°çš„MyBlogä¸‹\nç„¶åè¿›è¡Œpush\ncd MySite hugo -D cp -rf ./public/ ../MyBlog/ cd ../MyBlog git add . git commit -m \u0026#34;your comments\u0026#34; git push origin main pushæˆåŠŸåï¼Œç¨ç­‰2åˆ†é’Ÿï¼Œè®©fleekè‡ªåŠ¨æ‹‰å–ä½ æœ€æ–°çš„å†…å®¹å¹¶é‡æ–°éƒ¨ç½²\n  ç¬¬5æ­¥ makefile æˆ‘ä»¬ä½¿ç”¨makefileæ¥è®©æ–°å»ºBlogæ–‡ç« ã€æµ‹è¯•å’Œå‘å¸ƒæ˜¾å¾—è‡ªåŠ¨åŒ–ä¸€äº›\ncd MySite touch Makefile vim Makefile åœ¨Makefileä¸­åŠ å…¥ç±»ä¼¼ä¸‹é¢çš„å†…å®¹ï¼š\nall: \thugo -D \ttest: # To ignore errors in a command line, # write a - at the beginning of the line\u0026#39;s text (after the initial tab). # The - is discarded before the command is passed to the shell for execution \t-killall -9 hugo \thugo server -D \u0026amp; \tsleep 2 \topen http://localhost:1313/ \trelease: \thugo -D \tcp -rf ./public/ ../MyBlog/ \tcd ../MyBlog/ \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#34;auto updated by script\u0026#34; \u0026amp;\u0026amp; git push origin main \t##how to use: # make new file=this_is_one_article.md new: \thugo new posts/$(file) \topen ./content/posts/$(file) \u0026amp; å¤§åŠŸå‘Šæˆ ","permalink":"/posts/how_to_create_this_blog/","summary":"ç¬¬1æ­¥ï¼šåœ¨Githubä¸Šæ–°å»ºä¸€ä¸ªé¡¹ç›® ç™»å½•ä½ çš„Githubè´¦å·ï¼ŒæŒ‰ç…§å‘å¯¼ æ–°å»ºä¸€ä¸ª Repository\nå‡è®¾ä½ æ–°å»ºçš„Repoä¸ºï¼š https://github.com/yourUserName/MyBlog.git\nç¬¬2æ­¥ï¼š Cloneé¡¹ç›®åˆ°æœ¬åœ°å¹¶å°è¯•push git clone https://github.com/yourUserName/MyBlog.git å°è¯•æ–°å»ºä¸€ä¸ªæ–‡ä»¶å’Œpush\ncd MyBlog git init touch index.html echo \u0026#34;hi\u0026#34; \u0026gt;\u0026gt; index.html git add index.html git commit -m \u0026#34;add index.html\u0026#34; git branch -M main git remote add origin https://github.com/yourUserName/MyBlog.git git push -u origin main å°è¯•æäº¤çš„æ—¶å€™ï¼Œä¼šè®©ä½ è¾“å…¥githubè´¦å·å’Œtokenï¼ˆgitbubå¼ƒç”¨äº†å¯†ç ç™»å½•ï¼Œè€Œæ˜¯ä½¿ç”¨tokenï¼‰\nå¦‚æœä½ è¿˜æ²¡æœ‰ç”Ÿæˆè¿‡tokenï¼Œå¯ä»¥åˆ°Githubä½ è´¦æˆ·ä¸‹çš„settings -\u0026gt; Developer settings ä¸‹ç”Ÿæˆtoken\nç¬¬3æ­¥ï¼šä½¿ç”¨hugoè‡ªåŠ¨ç”Ÿæˆé™æ€ç½‘ç«™  å®‰è£…hugo  brew install hugo   æŒ‰ç…§å®˜æ–¹æ•™ç¨‹æ–°å»ºä¸€ä¸ªç½‘ç«™ å®˜æ–¹æ•™ç¨‹ï¼š https://gohugo.io/getting-started/quick-start/\nå‡è®¾ä½ çš„ç½‘ç«™åç§°å«MySite\n  ç¼–è¯‘ä½ çš„ç½‘ç«™ hugo -D ï¼Œç¼–è¯‘å‡ºæ¥çš„é™æ€ç½‘é¡µçš„å…¨éƒ¨å†…å®¹åœ¨MySite/publicç›®å½•ä¸‹\n  åœ¨æœ¬åœ°è¿è¡Œè¯•è¯• hugo server -D , ä¸å‡ºæ„å¤–ï¼Œä½ åº”è¯¥èƒ½åœ¨http://localhost:1313ä¸Šçœ‹åˆ°ä½ çš„ç«™ç‚¹","title":"å¦‚ä½•åˆ©ç”¨IFPSåˆ›å»ºè¿™ä¸ªåšå®¢"},{"content":"å…³äºè¿™ä¸ªBLOGï¼š è¿™ä¸ªBLOGçš„æ‰€æœ‰å†…å®¹å‡å­˜å‚¨åœ¨IPFSé“¾ä¸Šã€‚\nåŒæ—¶åœ¨Githubä¸Šä¹Ÿæœ‰å¯¹åº”å‰¯æœ¬ï¼š https://github.com/jack0x001/ChainBlog.git ã€‚\næˆ‘ä½¿ç”¨äº†gohugoæ¥è‡ªåŠ¨ç”Ÿæˆç½‘ç«™ å¹¶ä½¿ç”¨ fleekæ¥å°†å…¶è‡ªåŠ¨éƒ¨ç½²åˆ°IPFSä¸Šï¼Œ è¿™æ ·æˆ‘å°±å¯ä»¥å°†ç²¾åŠ›æ”¾åœ¨ç½‘ç«™å†…å®¹æœ¬èº«ä¸Šäº†ã€‚\n","permalink":"/posts/welcome/","summary":"å…³äºè¿™ä¸ªBLOGï¼š è¿™ä¸ªBLOGçš„æ‰€æœ‰å†…å®¹å‡å­˜å‚¨åœ¨IPFSé“¾ä¸Šã€‚\nåŒæ—¶åœ¨Githubä¸Šä¹Ÿæœ‰å¯¹åº”å‰¯æœ¬ï¼š https://github.com/jack0x001/ChainBlog.git ã€‚\næˆ‘ä½¿ç”¨äº†gohugoæ¥è‡ªåŠ¨ç”Ÿæˆç½‘ç«™ å¹¶ä½¿ç”¨ fleekæ¥å°†å…¶è‡ªåŠ¨éƒ¨ç½²åˆ°IPFSä¸Šï¼Œ è¿™æ ·æˆ‘å°±å¯ä»¥å°†ç²¾åŠ›æ”¾åœ¨ç½‘ç«™å†…å®¹æœ¬èº«ä¸Šäº†ã€‚","title":"Welcome"}]